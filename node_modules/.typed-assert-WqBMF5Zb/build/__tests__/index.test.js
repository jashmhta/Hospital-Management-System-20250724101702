"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = (0, tslib_1.__importDefault)(require("assert"));
const t = (0, tslib_1.__importStar)(require(".."));
class C {
}
const fixtures = {
    null: null,
    undefined: undefined,
    string: "",
    number: 0,
    boolean: true,
    date: new Date(),
    promise: Promise.resolve(null),
    record: {},
    array: [],
    recordWithKeys: {
        a: {
            b: {
                c: "d",
            },
            e: null,
        },
        f: "g",
    },
    recordOfStrings: {
        a: "",
        b: "",
    },
    recordOfNumbers: {
        a: 0,
        b: 1,
    },
    strings: ["a", "b", "c"],
    numbers: [0, 1, 2],
    c: new C(),
};
const entries = Object.entries(fixtures);
const orNull = (t) => t;
const orUndefined = (t) => t;
const baseAsserts = [
    ["default", t.defaultAssert],
    ["node", assert_1.default],
];
describe("typed-assert", () => {
    for (const [label, baseAssert] of baseAsserts) {
        describe(label, () => {
            t.setBaseAssert(baseAssert);
            test("isUnknown", () => {
                for (const value of Object.values(fixtures)) {
                    expect(() => t.isUnknown(value)).not.toThrow();
                }
            });
            test("isNever", () => {
                expect(() => {
                    const value = "a";
                    switch (value) {
                        case "a":
                        case "b":
                            return;
                    }
                    t.isNever(value);
                }).not.toThrow();
            });
            test("isNotNull", () => {
                const v = orNull(fixtures.string);
                t.isNotNull(v);
                // v is "string"
                for (const [key, value] of entries) {
                    if (key === "null") {
                        expect(() => t.isNotNull(value)).toThrow();
                    }
                    else {
                        expect(() => t.isNotNull(value)).not.toThrow();
                    }
                }
            });
            test("isNotUndefined", () => {
                const v = orUndefined(fixtures.string);
                t.isNotUndefined(v);
                // v is "string"
                for (const [key, value] of entries) {
                    if (key === "undefined") {
                        expect(() => t.isNotUndefined(value)).toThrow();
                    }
                    else {
                        expect(() => t.isNotUndefined(value)).not.toThrow();
                    }
                }
            });
            test("isNotVoid", () => {
                const v = orNull(orUndefined(fixtures.string));
                t.isNotVoid(v);
                // v is "string"
                for (const [key, value] of entries) {
                    if (key === "null" || key === "undefined") {
                        expect(() => t.isNotVoid(value)).toThrow();
                    }
                    else {
                        expect(() => t.isNotVoid(value)).not.toThrow();
                    }
                }
            });
            test("isExactly", () => {
                const v = orUndefined("value");
                t.isExactly(v, "value");
                // v is "value"
                for (const [, value] of entries) {
                    expect(() => t.isExactly(value, value)).not.toThrow();
                    for (const [, otherValue] of entries) {
                        if (otherValue !== value) {
                            expect(() => t.isExactly(value, otherValue)).toThrow();
                            expect(() => t.isExactly(otherValue, value)).toThrow();
                        }
                    }
                }
            });
            test("isBoolean", () => {
                const v = orNull(fixtures.boolean);
                t.isBoolean(v);
                // v is "boolean"
                for (const [key, value] of entries) {
                    if (key === "boolean") {
                        expect(() => t.isBoolean(value)).not.toThrow();
                    }
                    else {
                        expect(() => t.isBoolean(value)).toThrow();
                    }
                }
            });
            test("isNumber", () => {
                const v = orNull(fixtures.number);
                t.isNumber(v);
                // v is "number"
                for (const [key, value] of entries) {
                    if (key === "string") {
                        expect(() => t.isString(value)).not.toThrow();
                    }
                    else {
                        expect(() => t.isString(value)).toThrow();
                    }
                }
            });
            test("isString", () => {
                const v = orNull(fixtures.string);
                t.isString(v);
                // v is "string"
                for (const [key, value] of entries) {
                    if (key === "string") {
                        expect(() => t.isString(value)).not.toThrow();
                    }
                    else {
                        expect(() => t.isString(value)).toThrow();
                    }
                }
            });
            test("isDate", () => {
                const v = orNull(fixtures.date);
                t.isDate(v);
                // v is "Date"
                for (const [key, value] of entries) {
                    if (key === "date") {
                        expect(() => t.isDate(value)).not.toThrow();
                    }
                    else {
                        expect(() => t.isDate(value)).toThrow();
                    }
                }
            });
            test("isPromise", () => {
                const v = orNull(fixtures.promise);
                t.isPromise(v);
                // v is "Promise<null>"
                for (const [key, value] of entries) {
                    if (key === "promise") {
                        expect(() => t.isPromise(value)).not.toThrow();
                    }
                    else {
                        expect(() => t.isPromise(value)).toThrow();
                    }
                }
            });
            test("isRecord", () => {
                const v = orNull(fixtures.record);
                t.isRecord(v);
                // v is "Record<string, unkown>"
                for (const [key, value] of entries) {
                    if ([
                        "record",
                        "recordOfStrings",
                        "recordOfNumbers",
                        "recordWithKeys",
                        "date",
                        "promise",
                        "array",
                        "strings",
                        "numbers",
                        "c",
                    ].includes(key)) {
                        expect(() => t.isRecord(value)).not.toThrow();
                    }
                    else {
                        expect(() => t.isRecord(value)).toThrow();
                    }
                }
            });
            test("isArray", () => {
                const v = orNull(fixtures.array);
                t.isArray(v);
                // v is unknown[]
                for (const [key, value] of entries) {
                    if (["array", "strings", "numbers"].includes(key)) {
                        expect(() => t.isArray(value)).not.toThrow();
                    }
                    else {
                        expect(() => t.