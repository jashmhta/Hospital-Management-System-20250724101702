/// <reference types="@cloudflare/workers-types" />
import PrismaDefault from "@prisma/client/extension";
import { convertWireEventToPulseEvent, parsePulseWireEvent, } from "./data-types.js";
import { PrismaPulseError } from "./errors.js";
export class PulseSubscription extends ReadableStream {
    #controller;
    #ws;
    constructor(init) {
        const { endpoint, apiKey, model, modelName, where } = init;
        const controller = new AbortController();
        const { signal } = controller;
        const webSocketArgs = [
            endpoint,
            [],
            {
                headers: {
                    authorization: `Bearer ${apiKey}`,
                    subscription: JSON.stringify({
                        model,
                        modelName,
                        where,
                    }),
                    stream: JSON.stringify(init.stream),
                    "prisma-client-version": PrismaDefault.Prisma.prismaVersion.client,
                },
            },
        ];
        const wsDeferred = connectWebSocket(...webSocketArgs);
        super({
            cancel: () => this.stop(),
            start: async (controller) => {
                // loop to reconnect automatically if the WebSocket is disconnected
                // we will only break on error or explicit stop
                let ws = await wsDeferred;
                while (!signal.aborted) {
                    const stream = new WebSocketStream(ws).pipeThrough(new PulseEventDecoderStream(model));
                    for await (const event of stream) {
                        controller.enqueue(event);
                    }
                    if (!signal.aborted) {
                        // backoff the reconnect a bit
                        await wait(500);
                    }
                    // check if aborted again in case it was aborted during the wait
                    if (!signal.aborted) {
                        // reassign the class member for acknowledgement packets
                        this.#ws = connectWebSocket(...webSocketArgs);
                        ws = await this.#ws;
                    }
                }
            },
        });
        this.#controller = controller;
        this.#ws = wsDeferred;
    }
    get open() {
        return this.#ws.then((ws) => {
            if (ws.readyState === WebSocket.OPEN) {
                // If the connection is already open, return to avoid a Promise that never resolves.
                // Docs: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
                return Promise.resolve();
            }
            return new Promise((resolve, reject) => {
                ws.addEventListener("open", () => resolve(), { once: true });
                ws.addEventListener("error", (e) => reject(e.error), { once: true });
            });
        });
    }
    async *[Symbol.asyncIterator]() {
        for await (const event of super[Symbol.asyncIterator]()) {
            yield event;
            this.acknowledgeEvent(event.id);
        }
    }
    async acknowledgeEvent(id) {
        const msg = { type: "ack", id };
        const webSocket = await this.#ws;
        webSocket.send(JSON.stringify(msg));
    }
    async stop() {
        if (!this.#controller.signal.aborted) {
            // abort the controller to prevent any reconnects
            this.#controller.abort();
            // close the most recent WebSocket instance
            await this.#ws.then((ws) => ws.close());
        }
    }
}
/**
 * Connect a new WebSocket using the Workers fetch API.
 *
 * Fetch exposes more options, like HTTP headers, that are not available in the
 * `WebSocket` constructor. It also provides immediate feedback if there is an
 * error in establishing the connection.
 */
async function connectWebSocket(url, protocols, requestInit) {
    // initiate a WebSocket request using the Workers fetch approach
    const request = new Request(url.href, requestInit);
    request.headers.set("Upgrade", "websocket");
    request.headers.set("Sec-WebSocket-Extensions", "permessage-deflate");
    request.headers.set("Sec-WebSocket-Protocol", protocols.join(","));
    const response = await fetch(request);
    const { webSocket } = response;
    if (response.status !== 101 || !webSocket) {
        const body = await response.text().catch(() => "");
        const requestId = response.headers.get("cf-ray") ?? "unknown";
        throw PrismaPulseError.fromResponse(response.status, body, requestId);
    }
    // accept the WebSocket
    webSocket.accept();
    return webSocket;
}
function wait(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
/**
 * ReadableStream implementation that enqueues data received on the specified
 * WebSocket connection.
 */
class WebSocketStream extends ReadableStream {
    constructor(ws) {
        let closed = false;
        super({
            cancel() {
                closed = true;
                ws.close();
            },
            start(controller) {
                ws.addEventListener("close", () => {
                    if (!closed) {
                        controller.close();
                        closed = true;
                    }
                }, { once: true });
                ws.addEventListener("error", ({ error }) => {
                    if (!closed) {
                        controller.error(error);
                        closed = true;
                    }
                    if (error.name === "AbortError") {
                        controller.close();
                        closed = true;
                    }
                }, { once: true });
                ws.addEventListener("message", ({ data }) => {
                    if (!closed) {
                        controller.enqueue(data);
                    }
                });
            },
        });
    }
}
/**
 * TransformStream implementation that decodes WebSocket RawData (string,
 * Buffer, or Buffer[]) into a PulseEvent object for downstream consumers.
 */
class PulseEventDecoderStream extends TransformStream {
    constructor(model) {
        super({
            transform(rawData, controller) {
                const json = typeof rawData === "string"
                    ? rawData
                    : new TextDecoder().decode(rawData);
                const wireEvent = parsePulseWireEvent(json);
                const pulseEvent = convertWireEventToPulseEvent(wireEvent, model);
                controller.enqueue(pulseEvent);
            },
        });
    }
}
