import { Decimal } from "@prisma/client/runtime/index-browser.js";
// subscription filter operators
// https://github.com/prisma/pdp-cloudflare/blob/cd11a16461e95f33ec2bc64f8f46cd71abbfecb3/services/pulse-subscription/src/where.ts#L6
const operators = [
    "contains",
    "equals",
    "endsWith",
    "in",
    "notIn",
    "lt",
    "lte",
    "gt",
    "gte",
    "startsWith",
    "not",
    "mode",
    "has",
    "hasEvery",
    "hasSome",
];
// ./JsonProtocol.ts
const taggedTypes = ["DateTime", "Json", "Decimal", "Bytes", "BigInt"];
const isLogicalOperation = (value) => {
    return (value != null &&
        typeof value === "object" &&
        !Array.isArray(value) &&
        !!Object.keys(value).length &&
        Object.keys(value).every((k) => operators.includes(k)));
};
const isTaggedTypeName = (name) => {
    return (typeof name === "string" && taggedTypes.includes(name));
};
// from the orm client: https://github.com/prisma/prisma/blob/cb7aa393338d60f63241a2e4b36d24d45c4fffb0/packages/client/src/runtime/utils/date.ts
const isDate = (value) => value instanceof Date ||
    // date created in other JS context (for example, worker)
    Object.prototype.toString.call(value) === "[object Date]";
// still don't have isDecimalJsLike here ðŸ˜­
// https://github.com/prisma/prisma/blob/cb7aa393338d60f63241a2e4b36d24d45c4fffb0/packages/client/src/runtime/utils/decimalJsLike.ts
const isDecimal = (value) => {
    return (Decimal.isDecimal(value) ||
        (value != null &&
            typeof value === "object" &&
            "d" in value &&
            Array.isArray(value.d) &&
            "s" in value &&
            typeof value.s === "number" &&
            "e" in value &&
            typeof value.e === "number" &&
            "toFixed" in value &&
            typeof value.toFixed === "function"));
};
const isBytes = (value) => {
    return (ArrayBuffer.isView(value) ||
        (value != null &&
            typeof value === "object" &&
            "type" in value &&
            value["type"] === "Buffer" &&
            "data" in value &&
            Array.isArray(value["data"])));
};
// from the orm client: https://github.com/prisma/prisma/blob/445650a45b02a101e77e53d8a355a71bae0b29c2/packages/client/src/runtime/core/jsonProtocol/serializeJsonQuery.ts#L342-L344
const isJSONConvertible = (value) => {
    return (value !== null &&
        typeof value === "object" &&
        "toJSON" in value &&
        typeof value["toJSON"] === "function");
};
export class PulseSubscriptionFilterSerializer {
    #model;
    constructor(model) {
        this.#model = model;
    }
    serialize(args) {
        const serialized = { ...args };
        if (args.create) {
            serialized.create = this.#serializeFields(args.create);
        }
        if (args.delete) {
            serialized.delete = this.#serializeFields(args.delete);
        }
        if (args.update?.after) {
            serialized.update = {
                ...args.update,
                after: this.#serializeFields(args.update.after),
            };
        }
        return serialized;
    }
    #serializeFields(fields) {
        const serialized = {};
        for (const field in fields) {
            // AND, OR, and NOT are special top-level operators
            // https://github.com/prisma/pdp-cloudflare/blob/042be9efd841caf2f332dc2d51404f718100335f/services/pulse-subscription/src/where.ts#L93
            switch (field) {
                case "NOT":
                    serialized[field] = this.#serializeFields(fields[field]);
                    break;
                case "AND":
                case "OR":
                    serialized[field] = fields[field].map((x) => this.#serializeFields(x));
                    break;
                default:
                    serialized[field] = this.#serializeField(field, fields[field]);
                    break;
            }
        }
        return serialized;
    }
    #serializeField(name, value) {
        const fieldDefinition = this.#model.fields.find((f) => f.name === name);
        const type = fieldDefinition.type;
        // if the field is not a type that needs to be tagged, leave it alone
        if (!isTaggedTypeName(type)) {
            return value;
        }
        // no operators for json types
        // https://www.prisma.io/docs/orm/reference/prisma-client-reference#remarks-4
        return isLogicalOperation(value) && type !== "Json"
            ? this.#serializeOperation(type, value) // handle logical operations like 'equals', 'lt', 'hasEvery', etc.
            : this.#serializeValue(type, value); // handle raw values
    }
    #serializeValue(type, value) {
        if (Array.isArray(value)) {
            return value.map((v) => this.#serializeValue(type, v));
        }
        // we care about the schema field type, and not just the filter value type, for a couple reasons:
        // - it's not always clear from the value type whether the result should be tagged
        //   - is 2.2 a float (not tagged) or a decimal (tagged)?
        //   - is 1 an int (not tagged) or a bigint (tagged)?
        //   - is { in: [1, 2] } a json field (tagged) or an operator (recursed and potentially tagged)?
        // - with introspection we can give users an early warning if they mismatch their types
        switch (true) {
            case type === "DateTime" && isDate(value):
                return { $type: type, value: value.toISOString() };
            case type === "Decimal" && isDecimal(value):
                return { $type: type, value: value.toFixed() };
            case type === "Decimal" &&
                (typeof value === "number" || typeof value === "string"):
                return { $type: type, value: new Decimal(value).toFixed() }; // be helpful, coerce to decimal
            case type === "Bytes" && isBytes(value):
                return { $type: type, value: Buffer.from(value).toString("base64") };
            case type === "BigInt" && typeof value === "bigint":
                return { $type: type, value: String(value) };
            case type === "Json" && isJSONConvertible(value):
                return { $type: type, value: String(value.toJSON()) };
            case type === "Json" && typeof value === "object":
                return { $type: type, value: JSON.stringify(value) }; // this will choke on bigints, but maybe that's ok
        }
        // todo: types and values didn't match up so throw some kind of error here (but not this one)
        throw new Error(`field value ${JSON.stringify(value)} could not be converted to a ${type}`);
    }
    #serializeOperation(type, operations) {
        return Object.keys(operations).reduce((ops, op) => {
            const value = operations[op];
            ops[op] = isLogicalOperation(value)
                ? this.#serializeOperation(type, value) // recurse through nested operations
                : this.#serializeValue(type, value); // tag raw values
            return ops;
        }, {});
    }
}
