"use strict";
/// <reference types="node" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PulseSubscription = void 0;
const extension_1 = __importDefault(require("@prisma/client/extension"));
const node_http_1 = require("node:http");
const ws_1 = require("ws");
const data_types_js_1 = require("./data-types.js");
const errors_js_1 = require("./errors.js");
class PulseSubscription extends ReadableStream {
    #controller;
    #ws;
    constructor(init) {
        const { endpoint, apiKey, model, modelName, where } = init;
        const controller = new AbortController();
        const { signal } = controller;
        // prepare WebSocket constructor args for reuse
        const webSocketArgs = [
            endpoint.href,
            [],
            {
                headers: {
                    authorization: `Bearer ${apiKey}`,
                    subscription: JSON.stringify({
                        model,
                        modelName,
                        where,
                    }),
                    stream: JSON.stringify(init.stream),
                    "prisma-client-version": extension_1.default.Prisma.prismaVersion.client,
                },
            },
        ];
        // connect the initial WebSocket
        // this is done outside the start() function to provide access earlier
        // start() won't run until the ReadableStream has a reader attached
        let ws = new ws_1.WebSocket(...webSocketArgs);
        super({
            cancel: () => {
                this.stop();
            },
            start: async (controller) => {
                // loop to reconnect automatically if the WebSocket is disconnected
                // we will only break on error or explicit stop
                while (!signal.aborted) {
                    startPingPong(ws);
                    const stream = new WebSocketStream(ws).pipeThrough(new PulseEventDecoderStream(model));
                    try {
                        for await (const event of stream) {
                            controller.enqueue(event);
                        }
                    }
                    catch (reason) {
                        // cath the thrown connection error and convert to Pulse error
                        if (reason instanceof node_http_1.IncomingMessage) {
                            const body = await readBody(reason);
                            const error = errors_js_1.PrismaPulseError.fromResponse(reason.statusCode, body);
                            throw error;
                        }
                        // everything else throws as-is
                        throw reason;
                    }
                    if (!signal.aborted) {
                        // backoff the reconnect a bit
                        await wait(500);
                    }
                    // check if aborted again in case it was aborted during the wait
                    if (!signal.aborted) {
                        // reassign the class member for acknowledgement packets
                        this.#ws = ws = new ws_1.WebSocket(...webSocketArgs);
                    }
                }
                controller.close();
            },
        });
        this.#controller = controller;
        this.#ws = ws;
    }
    get open() {
        if (this.#ws.readyState === ws_1.WebSocket.OPEN) {
            // the promise below would never resolved if the connection was already open
            // Docs: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            this.#ws.once("open", () => resolve());
            this.#ws.once("error", (e) => reject(e));
            this.#ws.once("unexpected-response", async (req, res) => {
                const body = await readBody(res);
                const requestId = res.headers["cf-ray"]
                    ? res.headers["cf-ray"]
                    : "unknown";
                const error = errors_js_1.PrismaPulseError.fromResponse(res.statusCode, body, requestId);
                reject(error);
            });
        });
    }
    async *[Symbol.asyncIterator]() {
        for await (const event of super[Symbol.asyncIterator]()) {
            yield event;
            this.acknowledgeEvent(event.id);
        }
    }
    acknowledgeEvent(id) {
        const msg = { type: "ack", id };
        this.#ws.send(JSON.stringify(msg));
    }
    stop() {
        if (!this.#controller.signal.aborted) {
            // abort the controller to prevent any reconnects
            this.#controller.abort();
            // close the most recent WebSocket instance
            this.#ws.close();
        }
    }
}
exports.PulseSubscription = PulseSubscription;
function readBody(res) {
    return new Promise((resolve) => {
        const data = new Array();
        res.on("data", (chunk) => data.push(chunk));
        res.on("end", () => resolve(data.join("")));
    });
}
function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * ReadableStream implementation that enqueues data received on the specified
 * WebSocket connection.
 */
class WebSocketStream extends ReadableStream {
    constructor(ws) {
        let closed = false;
        super({
            cancel() {
                closed = true;
                ws.close();
            },
            start(controller) {
                ws.once("close", () => {
                    if (!closed) {
                        controller.close();
                        closed = true;
                    }
                });
                ws.once("unexpected-response", async (req, res) => {
                    const body = await readBody(res);
                    const error = errors_js_1.PrismaPulseError.fromResponse(res.statusCode, body);
                    if (!closed) {
                        controller.error(error);
                        closed = true;
                    }
                });
                ws.once("error", (error) => {
                    if (!closed) {
                        controller.error(error);
                        closed = true;
                    }
                    if (error.name === "AbortError") {
                        controller.close();
                        closed = true;
                    }
                });
                ws.on("message", (data) => {
                    if (!closed) {
                        controller.enqueue(data);
                    }
                });
            },
        });
    }
}
/**
 * TransformStream implementation that decodes WebSocket RawData (string,
 * Buffer, or Buffer[]) into a PulseEvent object for downstream consumers.
 */
class PulseEventDecoderStream extends TransformStream {
    constructor(model) {
        super({
            transform(rawData, controller) {
                const json = Buffer.isBuffer(rawData)
                    ? rawData.toString()
                    : Array.isArray(rawData)
                        ? Buffer.concat(rawData).toString()
                        : new TextDecoder().decode(rawData);
                const wireEvent = (0, data_types_js_1.parsePulseWireEvent)(json);
                const pulseEvent = (0, data_types_js_1.convertWireEventToPulseEvent)(wireEvent, model);
                controller.enqueue(pulseEvent);
            },
        });
    }
}
// /** Kills the WebSocket after a random timeout. */
// function introduceChaos(ws: WebSocket) {
//   const timeout = Math.floor(Math.random() * 10000);
//   console.debug(`killing WebSocket in ${timeout}ms`);
//   setTimeout(() => ws.terminate(), timeout);
// }
/**
 * Start a ping/pong loop to verify the status of the specified WebSocket.
 *
 * WebSocket connections don't always signal network connectivity issues when
 * there is no outbound traffic. This ensures we detect a broken connection and
 * force a discconnect with terminate(). The caller may then recover the
 * connection if it is still needed.
 */
function startPingPong(ws) {
    const interval = setInterval(() => {
        if (ws.readyState === ws_1.WebSocket.OPEN) {
            const timeout = setTimeout(() => ws.terminate(), 1000);
            ws.once("pong", () => clearTimeout(timeout));
            ws.ping();
        }
    }, 5000);
    ws.once("close", () => clearInterval(interval));
}
