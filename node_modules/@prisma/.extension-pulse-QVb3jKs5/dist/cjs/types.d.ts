import type { Prisma } from "@prisma/client/extension";
export type PulseEvent<T> = PulseCreateEvent<T> | PulseDeleteEvent<T> | PulseUpdateEvent<T>;
export interface PulseCreateEvent<T> {
    created: T;
    action: "create";
    id: string;
}
export interface PulseDeleteEvent<T> {
    deleted: T;
    action: "delete";
    id: string;
}
export interface PulseUpdateEvent<T> {
    after: T;
    action: "update";
    id: string;
}
type RecursiveOmit<T, G> = T extends Function ? T : T extends object ? {
    [K in keyof T as K extends G ? never : K]: RecursiveOmit<T[K], G>;
} : T;
export type ScalarFields<T> = RecursiveOmit<Prisma.Args<T, "findMany">["where"], keyof Prisma.Payload<T, "findMany">["objects"]>;
export interface PulseSubscribeArgs<Model> {
    create?: ScalarFields<Model>;
    delete?: ScalarFields<Model>;
    update?: {
        after?: ScalarFields<Model>;
    };
}
export interface PulseStreamArgs<Model> extends PulseSubscribeArgs<Model> {
    name?: string;
}
interface PulseResultTypeMap<T> {
    create: PulseCreateEvent<T>;
    delete: PulseDeleteEvent<T>;
    update: PulseUpdateEvent<T>;
}
export type PulseResultType<Args, Data> = Record<string, never> extends Args ? PulseResultTypeMap<Data>[keyof PulseResultTypeMap<Data>] : {
    [K in keyof Args]: K extends keyof PulseResultTypeMap<Data> ? PulseResultTypeMap<Data>[K] : never;
}[keyof Args];
export type InferPulseResultType<Model, Args> = PulseResultType<Omit<Args, "name">, Prisma.Result<Model, Args, "findFirstOrThrow">>;
export type Omit<T, K extends string | number | symbol> = {
    [P in keyof T as P extends K ? never : P]: T[P];
};
export {};
