"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertWireEventToPulseEvent = exports.parsePulseWireEvent = void 0;
const index_browser_js_1 = require("@prisma/client/runtime/index-browser.js");
function parsePulseWireEvent(json) {
    const data = JSON.parse(json);
    return data;
}
exports.parsePulseWireEvent = parsePulseWireEvent;
/**
 * Converts a wire event from the Pulse WebSocket into the corresponding
 * `PulseEvent` type that users expect.
 *
 * JSON cannot represent all data types, so they are serialized as strings or
 * enveloped values over the wire.
 */
function convertWireEventToPulseEvent(event, model) {
    switch (event.action) {
        case "create":
            return {
                ...event,
                action: "create",
                created: deserializeJsonResponse(event.created, model),
            };
        case "delete":
            return {
                ...event,
                action: "delete",
                deleted: deserializeJsonResponse(event.deleted, model),
            };
        case "update":
            return {
                ...event,
                action: "update",
                after: deserializeJsonResponse(event.after, model),
            };
    }
}
exports.convertWireEventToPulseEvent = convertWireEventToPulseEvent;
/**
 * Returns true if the specified value is a tagged, complex type envelope.
 */
function isTaggedValue(value) {
    return (value !== null &&
        typeof value == "object" &&
        "$type" in value &&
        typeof value["$type"] === "string");
}
/**
 * Deserializes a JSON value according to the Prisma ORM JSON protocol spec.
 * Copied from [here](https://github.com/prisma/prisma/blob/4caf2912e5abcc6eb0fc4c5e0d447614ce4c29d3/packages/client/src/runtime/core/jsonProtocol/deserializeJsonResponse.ts).
 */
function deserializeJsonResponse(result, model) {
    if (result === null) {
        return result;
    }
    if (Array.isArray(result)) {
        return result.map((r) => deserializeJsonResponse(r, model));
    }
    if (typeof result === "object") {
        if (isTaggedValue(result)) {
            return deserializeTaggedValue(result);
        }
        for (const [key, value] of Object.entries(result)) {
            // @ts-ignore
            result[key] = deserializeJsonResponse(value);
            // if the field is supposed to be an array and the wire event value is a null, make it an empty array
            if (
            // @ts-ignore
            result[key] === null &&
                model?.fields.find((f) => f.name === key)?.isList) {
                // @ts-ignore
                result[key] = [];
            }
        }
        return result;
    }
    return result;
}
/**
 * Transforms the specified wire value into the expected type based on the
 * tagged field types for complex fields.
 *
 * JSON cannot represent all data types, so they are serialized as strings or
 * tagged, enveloped values over the wire.
 */
function deserializeTaggedValue({ $type, value, }) {
    switch ($type) {
        case "BigInt":
            return BigInt(value);
        case "Bytes":
            return Buffer.from(value, "base64");
        case "DateTime":
            return new Date(value);
        case "Decimal":
            return new index_browser_js_1.Decimal(value);
        case "Json":
            return JSON.parse(value);
        default:
            // TODO: should we error or return the value as-is?
            return value;
    }
}
