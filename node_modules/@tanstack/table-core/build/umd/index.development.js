/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TableCore = {}));
})(this, (function (exports) { 'use strict';

  // type Person = {
  //   firstName: string
  //   lastName: string
  //   age: number
  //   visits: number
  //   status: string
  //   progress: number
  //   createdAt: Date
  //   nested: {
  //     foo: [
  //       {
  //         bar: 'bar'
  //       }
  //     ]
  //     bar: { subBar: boolean }[]
  //     baz: {
  //       foo: 'foo'
  //       bar: {
  //         baz: 'baz'
  //       }
  //     }
  //   }
  // }

  // const test: DeepKeys<Person> = 'nested.foo.0.bar'
  // const test2: DeepKeys<Person> = 'nested.bar'

  // const helper = createColumnHelper<Person>()

  // helper.accessor('nested.foo', {
  //   cell: info => info.getValue(),
  // })

  // helper.accessor('nested.foo.0.bar', {
  //   cell: info => info.getValue(),
  // })

  // helper.accessor('nested.bar', {
  //   cell: info => info.getValue(),
  // })

  function createColumnHelper() {
    return {
      accessor: (accessor, column) => {
        return typeof accessor === 'function' ? {
          ...column,
          accessorFn: accessor
        } : {
          ...column,
          accessorKey: accessor
        };
      },
      display: column => column,
      group: column => column
    };
  }

  // Is this type a tuple?

  // If this type is a tuple, what indices are allowed?

  ///

  function functionalUpdate(updater, input) {
    return typeof updater === 'function' ? updater(input) : updater;
  }
  function noop() {
    //
  }
  function makeStateUpdater(key, instance) {
    return updater => {
      instance.setState(old => {
        return {
          ...old,
          [key]: functionalUpdate(updater, old[key])
        };
      });
    };
  }
  function isFunction(d) {
    return d instanceof Function;
  }
  function isNumberArray(d) {
    return Array.isArray(d) && d.every(val => typeof val === 'number');
  }
  function flattenBy(arr, getChildren) {
    const flat = [];
    const recurse = subArr => {
      subArr.forEach(item => {
        flat.push(item);
        const children = getChildren(item);
        if (children != null && children.length) {
          recurse(children);
        }
      });
    };
    recurse(arr);
    return flat;
  }
  function memo(getDeps, fn, opts) {
    let deps = [];
    let result;
    return depArgs => {
      let depTime;
      if (opts.key && opts.debug) depTime = Date.now();
      const newDeps = getDeps(depArgs);
      const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
      if (!depsChanged) {
        return result;
      }
      deps = newDeps;
      let resultTime;
      if (opts.key && opts.debug) resultTime = Date.now();
      result = fn(...newDeps);
      opts == null || opts.onChange == null || opts.onChange(result);
      if (opts.key && opts.debug) {
        if (opts != null && opts.debug()) {
          const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
          const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
          const resultFpsPercentage = resultEndTime / 16;
          const pad = (str, num) => {
            str = String(str);
            while (str.length < num) {
              str = ' ' + str;
            }
            return str;
          };
          console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
        }
      }
      return result;
    };
  }
  function getMemoOptions(tableOptions, debugLevel, key, onChange) {
    return {
      debug: () => {
        var _tableOptions$debugAl;
        return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
      },
      key: key,
      onChange
    };
  }

  function createCell(table, row, column, columnId) {
    const getRenderValue = () => {
      var _cell$getValue;
      return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
    };
    const cell = {
      id: `${row.id}_${column.id}`,
      row,
      column,
      getValue: () => row.getValue(columnId),
      renderValue: getRenderValue,
      getContext: memo(() => [table, column, row, cell], (table, column, row, cell) => ({
        table,
        column,
        row,
        cell: cell,
        getValue: cell.getValue,
        renderValue: cell.renderValue
      }), getMemoOptions(table.options, 'debugCells', 'cell.getContext'))
    };
    table._features.forEach(feature => {
      feature.createCell == null || feature.createCell(cell, column, row, table);
    }, {});
    return cell;
  }

  function createColumn(table, columnDef, depth, parent) {
    var _ref, _resolvedColumnDef$id;
    const defaultColumn = table._getDefaultColumnDef();
    const resolvedColumnDef = {
      ...defaultColumn,
      ...columnDef
    };
    const accessorKey = resolvedColumnDef.accessorKey;
    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === 'function' ? accessorKey.replaceAll('.', '_') : accessorKey.replace(/\./g, '_') : undefined) != null ? _ref : typeof resolvedColumnDef.header === 'string' ? resolvedColumnDef.header : undefined;
    let accessorFn;
    if (resolvedColumnDef.accessorFn) {
      accessorFn = resolvedColumnDef.accessorFn;
    } else if (accessorKey) {
      // Support deep accessor keys
      if (accessorKey.includes('.')) {
        accessorFn = originalRow => {
          let result = originalRow;
          for (const key of accessorKey.split('.')) {
            var _result;
            result = (_result = result) == null ? void 0 : _result[key];
            if (result === undefined) {
              console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
            }
          }
          return result;
        };
      } else {
        accessorFn = originalRow => originalRow[resolvedColumnDef.accessorKey];
      }
    }
    if (!id) {
      {
        throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
      }
    }
    let column = {
      id: `${String(id)}`,
      accessorFn,
      parent: parent,
      depth,
      columnDef: resolvedColumnDef,
      columns: [],
      getFlatColumns: memo(() => [true], () => {
        var _column$columns;
        return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];
      }, getMemoOptions(table.options, 'debugColumns', 'column.getFlatColumns')),
      getLeafColumns: memo(() => [table._getOrderColumnsFn()], orderColumns => {
        var _column$columns2;
        if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
          let leafColumns = column.columns.flatMap(column => column.getLeafColumns());
          return orderColumns(leafColumns);
        }
        return [column];
      }, getMemoOptions(table.options, 'debugColumns', 'column.getLeafColumns'))
    };
    for (const feature of table._features) {
      feature.createColumn == null || feature.createColumn(column, table);
    }

    // Yes, we have to convert table to unknown, because we know more than the compiler here.
    return column;
  }

  const debug = 'debugHeaders';
  //

  function createHeader(table, column, options) {
    var _options$id;
    const id = (_options$id = options.id) != null ? _options$id : column.id;
    let header = {
      id,
      column,
      index: options.index,
      isPlaceholder: !!options.isPlaceholder,
      placeholderId: options.placeholderId,
      depth: options.depth,
      subHeaders: [],
      colSpan: 0,
      rowSpan: 0,
      headerGroup: null,
      getLeafHeaders: () => {
        const leafHeaders = [];
        const recurseHeader = h => {
          if (h.subHeaders && h.subHeaders.length) {
            h.subHeaders.map(recurseHeader);
          }
          leafHeaders.push(h);
        };
        recurseHeader(header);
        return leafHeaders;
      },
      getContext: () => ({
        table,
        header: header,
        column
      })
    };
    table._features.forEach(feature => {
      feature.createHeader == null || feature.createHeader(header, table);
    });
    return header;
  }
  const Headers = {
    createTable: table => {
      // Header Groups

      table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
        var _left$map$filter, _right$map$filter;
        const leftColumns = (_left$map$filter = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
        const rightColumns = (_right$map$filter = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
        const centerColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
        const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
        return headerGroups;
      }, getMemoOptions(table.options, debug, 'getHeaderGroups'));
      table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
        leafColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
        return buildHeaderGroups(allColumns, leafColumns, table, 'center');
      }, getMemoOptions(table.options, debug, 'getCenterHeaderGroups'));
      table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
        var _left$map$filter2;
        const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
        return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'left');
      }, getMemoOptions(table.options, debug, 'getLeftHeaderGroups'));
      table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
        var _right$map$filter2;
        const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
        return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'right');
      }, getMemoOptions(table.options, debug, 'getRightHeaderGroups'));

      // Footer Groups

      table.getFooterGroups = memo(() => [table.getHeaderGroups()], headerGroups => {
        return [...headerGroups].reverse();
      }, getMemoOptions(table.options, debug, 'getFooterGroups'));
      table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], headerGroups => {
        return [...headerGroups].reverse();
      }, getMemoOptions(table.options, debug, 'getLeftFooterGroups'));
      table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], headerGroups => {
        return [...headerGroups].reverse();
      }, getMemoOptions(table.options, debug, 'getCenterFooterGroups'));
      table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], headerGroups => {
        return [...headerGroups].reverse();
      }, getMemoOptions(table.options, debug, 'getRightFooterGroups'));

      // Flat Headers

      table.getFlatHeaders = memo(() => [table.getHeaderGroups()], headerGroups => {
        return headerGroups.map(headerGroup => {
          return headerGroup.headers;
        }).flat();
      }, getMemoOptions(table.options, debug, 'getFlatHeaders'));
      table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], left => {
        return left.map(headerGroup => {
          return headerGroup.headers;
        }).flat();
      }, getMemoOptions(table.options, debug, 'getLeftFlatHeaders'));
      table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], left => {
        return left.map(headerGroup => {
          return headerGroup.headers;
        }).flat();
      }, getMemoOptions(table.options, debug, 'getCenterFlatHeaders'));
      table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], left => {
        return left.map(headerGroup => {
          return headerGroup.headers;
        }).flat();
      }, getMemoOptions(table.options, debug, 'getRightFlatHeaders'));

      // Leaf Headers

      table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], flatHeaders => {
        return flatHeaders.filter(header => {
          var _header$subHeaders;
          return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
        });
      }, getMemoOptions(table.options, debug, 'getCenterLeafHeaders'));
      table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], flatHeaders => {
        return flatHeaders.filter(header => {
          var _header$subHeaders2;
          return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
        });
      }, getMemoOptions(table.options, debug, 'getLeftLeafHeaders'));
      table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], flatHeaders => {
        return flatHeaders.filter(header => {
          var _header$subHeaders3;
          return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
        });
      }, getMemoOptions(table.options, debug, 'getRightLeafHeaders'));
      table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
        var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
        return [...((_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : []), ...((_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : []), ...((_right$0$headers = (_right$ = right[0]) == nu