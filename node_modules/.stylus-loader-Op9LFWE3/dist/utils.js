"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEvaluator = createEvaluator;
exports.getStylusImplementation = getStylusImplementation;
exports.getStylusOptions = getStylusOptions;
exports.normalizeSourceMap = normalizeSourceMap;
exports.readFile = readFile;
exports.resolveFilename = resolveFilename;
exports.urlResolver = urlResolver;
var _url = require("url");
var _path = _interopRequireDefault(require("path"));
var _stylus = require("stylus");
var _depsResolver = _interopRequireDefault(require("stylus/lib/visitor/deps-resolver"));
var _fastGlob = _interopRequireDefault(require("fast-glob"));
var _normalizePath = _interopRequireDefault(require("normalize-path"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Examples:
// - ~package
// - ~package/
// - ~@org
// - ~@org/
// - ~@org/package
// - ~@org/package/
const IS_MODULE_IMPORT = /^~([^/]+|[^/]+\/|@[^/]+[/][^/]+|@[^/]+\/?|@[^/]+[/][^/]+\/)$/;
const MODULE_REQUEST_REGEX = /^[^?]*~/;
function isProductionLikeMode(loaderContext) {
  return loaderContext.mode === "production" || !loaderContext.mode;
}
function getStylusOptions(loaderContext, loaderOptions) {
  const options = typeof loaderOptions.stylusOptions === "function" ? loaderOptions.stylusOptions(loaderContext) || {} : loaderOptions.stylusOptions || {};
  const stylusOptions = {
    filename: loaderContext.resourcePath,
    dest: _path.default.dirname(loaderContext.resourcePath),
    ...options,
    // Keep track of imported files (used by Stylus CLI watch mode)
    // eslint-disable-next-line no-underscore-dangle
    // Don't allow to override, because it is internally
    _imports: []
  };

  // https://github.com/stylus/stylus/issues/2119
  stylusOptions.resolveURL = typeof stylusOptions.resolveURL === "boolean" && !stylusOptions.resolveURL ? false : typeof stylusOptions.resolveURL === "object" ? {
    ...stylusOptions.resolveURL
  } : {
    nocheck: true
  };
  if (typeof stylusOptions.compress === "undefined" && isProductionLikeMode(loaderContext)) {
    stylusOptions.compress = true;
  }
  return stylusOptions;
}
function getStylusImplementation(loaderContext, implementation) {
  let resolvedImplementation = implementation;
  if (!implementation || typeof implementation === "string") {
    const stylusImplPkg = implementation || "stylus";

    // eslint-disable-next-line import/no-dynamic-require, global-require
    resolvedImplementation = require(stylusImplPkg);
  }

  // eslint-disable-next-line consistent-return
  return resolvedImplementation;
}
function getPossibleRequests(loaderContext, filename) {
  let request = filename;

  // A `~` makes the url an module
  if (MODULE_REQUEST_REGEX.test(filename)) {
    request = request.replace(MODULE_REQUEST_REGEX, "");
  }
  if (IS_MODULE_IMPORT.test(filename)) {
    request = request[request.length - 1] === "/" ? request : `${request}/`;
  }
  return [...new Set([request, filename])];
}
async function resolveFilename(loaderContext, fileResolver, globResolver, isGlob, context, filename) {
  const possibleRequests = getPossibleRequests(loaderContext, filename);
  let result;
  try {
    result = await resolveRequests(context, possibleRequests, fileResolver);
  } catch (error) {
    if (isGlob) {
      const [globTask] = _fastGlob.default.generateTasks(filename);
      if (globTask.base === ".") {
        throw new Error('Glob resolving without a glob base ("~**/*") is not supported, please specify a glob base ("~package/**/*")');
      }
      const possibleGlobRequests = getPossibleRequests(loaderContext, globTask.base);
      let globResult;
      try {
        globResult = await resolveRequests(context, possibleGlobRequests, globResolver);
      } catch (globError) {
        throw globError;
      }
      loaderContext.addContextDependency(globResult);
      const patterns = filename.replace(new RegExp(`^${globTask.base}`), (0, _normalizePath.default)(globResult));
      const paths = await (0, _fastGlob.default)(patterns, {
        absolute: true,
        cwd: globResult
      });
      return paths.sort().filter(file => /\.styl$/i.test(file));
    }
    throw error;
  }
  return result;
}
async function resolveRequests(context, possibleRequests, resolve) {
  if (possibleRequests.length === 0) {
    return Promise.reject();
  }
  let result;
  try {
    result = await resolve(context, possibleRequests[0]);
  } catch (error) {
    const [, ...tailPossibleRequests] = possibleRequests;
    if (tailPossibleRequests.length === 0) {
      throw error;
    }
    result = await resolveRequests(context, tailPossibleRequests, resolve);
  }
  return result;
}
const URL_RE = /^(?:url\s*\(\s*)?['"]?(?:[#/]|(?:https?:)?\/\/)/i;
async function getDependencies(resolvedDependencies, loaderContext, fileResolver, globResolver, seen, code, filename, options) {
  seen.add(filename);

  // See https://github.com/stylus/stylus/issues/2108
  const newOptions = {
    ...options,
    filename,
    cache: false
  };
  const parser = new _stylus.Parser(code, newOptions);
  let ast;
  try {
    ast = parser.parse();
  } catch (error) {
    loaderContext.emitError(error);
    return;
  }
  const dependencies = [];
  class ImportVisitor extends _depsResolver.default {
    // eslint-disable-next-line class-methods-use-this
    visitImport(node) {
      let firstNode = node.path.first;
      if (firstNode.name === "url") {
        return;
      }
      if (!firstNode.val) {
        const evaluator = new _stylus.Evaluator(ast);
        firstNode = evaluator.visit.call(evaluator, firstNode).first;
      }
      const originalNodePath = !firstNode.val.isNull && firstNode.val || firstNode.name;
      let nodePath = originalNodePath;
      if (!nodePath) {
        return;
      }
      let found;
      let oldNodePath;
      const literal = /\.css(?:"|$)/.test(nodePath);
      if (!literal && !/\.styl$/i.test(nodePath)) {
        oldNodePath = nodePath;
        nodePath += ".styl";
      }
      const isGlob = _fastGlob.default.isDynamicPattern(nodePath);
      found = _stylus.utils.find(nodePath, this.paths, this.filename);
      if (found && isGlob) {
        const [globTask] = _fastGlob.default.generateTasks(nodePath);
        const context = globTask.base === "." ? _path.default.dirname(this.filename) : _path.default.join(_path.default.dirname(this.filename), globTask.base);
        loaderContext.addContextDependency(context);
      }
      if (!found && oldNodePath) {
        found = _stylus.utils.lookupIndex(oldNodePath, this.paths, this.filename);
      }
      if (found) {
        dependencies.push({
          originalLineno: firstNode.lineno,
          originalColumn: firstNode.column,
          originalNodePath,
          resolved: found.map(item => _path.default.isAbsolute(item) ? item : _path.default.join(process.cwd(), item))
        });
        return;
      }
      dependencies.push({
        originalLineno: firstNode.lineno,
        originalColumn: firstNode.column,
        originalNodePath,
        resolved: resolveFilename(loaderContext, fileResolver, globResolver, isGlob, _path.default.dirname(this.filename), originalNodePath)
      });
    }
  }
  new ImportVisitor(ast, newOptions).visit(ast);
  await Promise.all(Array.from(dependencies).map(async result => {
    let {
      resolved
    } = result;
    try {
      resolved = await resolved;
    } catch (ignoreError) {
      // eslint-disable-next-line no-param-reassign
      delete result.resolved;

      // eslint-disable-next-line no-param-reassign
      result.error = ignoreError;
      return;
    }
    const isArray = Array.isArray(reso