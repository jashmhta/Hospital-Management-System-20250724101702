var __DEV__: boolean;
  interface Window {
    [key: string]: any;
  }
  namespace NodeJS {
    interface Global {
      [key: string]: any;
    }
  }
}

/**
 * Enterprise Audit Logging Service;
 * Implements comprehensive audit trail for compliance and security monitoring;
 * Based on enterprise requirements from ZIP 6 resources and healthcare regulations (HIPAA, etc.)
 */

import { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { PrismaClient } from '@prisma/client';\nimport crypto from 'crypto';\n\nexport interface AuditEvent {\n  id: string;\n  timestamp: Date;\n  eventType: AuditEventType;\n  category: AuditCategory;\n  severity: AuditSeverity;\n  actor: AuditActor;\n  resource: AuditResource;\n  action: string;\n  outcome: 'success' | 'failure' | 'pending';\n  details: AuditDetails;\n  context: AuditContext;\n  compliance: ComplianceInfo;\n  integrity: IntegrityInfo;\n}\n\nexport type AuditEventType = \n  | 'authentication'\n  | 'authorization'\n  | 'data_access'\n  | 'data_modification'\n  | 'system_event'\n  | 'security_event'\n  | 'compliance_event'\n  | 'clinical_event'\n  | 'administrative_event';\n\nexport type AuditCategory = \n  | 'patient_data'\n  | 'clinical_data'\n  | 'financial_data'\n  | 'administrative_data'\n  | 'system_data'\n  | 'user_management'\n  | 'security'\n  | 'compliance';\n\nexport type AuditSeverity = 'low' | 'medium' | 'high' | 'critical';\n\nexport interface AuditActor {\n  type: 'user' | 'system' | 'service' | 'external';\n  id: string;\n  name?: string;\n  role?: string;\n  department?: string;\n  organizationId?: string;\n  sessionId?: string;\n  impersonatedBy?: string;\n}\n\nexport interface AuditResource {\n  type: string;\n  id?: string;\n  name?: string;\n  patientId?: string; // For patient-related resources\n  organizationId?: string;\n  location?: string;\n  classification?: 'public' | 'internal' | 'confidential' | 'restricted';\n}\n\nexport interface AuditDetails {\n  description: string;\n  beforeState?: unknown;\n  afterState?: unknown;\n  changedFields?: string[];\n  searchCriteria?: unknown;\n  resultCount?: number;\n  errorMessage?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface AuditContext {\n  requestId?: string;\n  sessionId?: string;\n  ipAddress?: string;\n  userAgent?: string;\n  deviceId?: string;\n  location?: {\n    country?: string;\n    region?: string;\n    city?: string;\n  };\n  workflow?: {\n    processId?: string;\n    stepId?: string;\n    processName?: string;\n  };\n}\n\nexport interface ComplianceInfo {\n  regulations: ComplianceRegulation[];\n  dataTypes: string[];\n  retentionPeriod?: number; // in days\n  privacyImpact?: 'none' | 'low' | 'medium' | 'high';\n  consentRequired?: boolean;\n  consentStatus?: 'granted' | 'denied' | 'pending' | 'withdrawn';\n}\n\nexport type ComplianceRegulation = 'HIPAA' | 'GDPR' | 'SOX' | 'FDA' | 'HITECH' | 'state_law' | 'local_regulation';\n\nexport interface IntegrityInfo {\n  hash: string;\n  algorithm: string;\n  signature?: string;\n  previousHash?: string;\n  blockNumber?: number;\n}\n\nexport interface AuditQuery {\n  startDate?: Date;\n  endDate?: Date;\n  eventTypes?: AuditEventType[];\n  categories?: AuditCategory[];\n  severities?: AuditSeverity[];\n  actorId?: string;\n  actorType?: string;\n  resourceType?: string;\n  resourceId?: string;\n  patientId?: string;\n  organizationId?: string;\n  outcome?: string;\n  searchText?: string;\n  limit?: number;\n  offset?: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface AuditReport {\n  id: string;\n  title: string;\n  description: string;\n  query: AuditQuery;\n  events: AuditEvent[];\n  statistics: AuditStatistics;\n  generatedAt: Date;\n  generatedBy: string;\n  format: 'json' | 'csv' | 'pdf' | 'xml';\n  complianceFlags: string[];\n}\n\nexport interface AuditStatistics {\n  totalEvents: number;\n  eventsByType: Record<string, number>;\n  eventsByCategory: Record<string, number>;\n  eventsBySeverity: Record<string, number>;\n  eventsByOutcome: Record<string, number>;\n  uniqueActors: number;\n  uniqueResources: number;\n  timeRange: {\n    start: Date;\n    end: Date;\n  };\n  complianceMetrics: {\n    totalPatientDataAccess: number;\n    unauthorizedAttempts: number;\n    consentViolations: number;\n    dataExports: number;\n  };\n}\n\nexport interface AuditAlert {\n  id: string;\n  name: string;\n  description: string;\n  conditions: AuditAlertCondition[];\n  actions: AuditAlertAction[];\n  isActive: boolean;\n  severity: AuditSeverity;\n  createdAt: Date;\n  createdBy: string;\n  lastTriggered?: Date;\n  triggerCount: number;\n}\n\nexport interface AuditAlertCondition {\n  field: string;\n  operator: 'equals' | 'not_equals' | 'contains' | 'greater_than' | 'less_than' | 'in' | 'not_in';\n  value: unknown;\n  timeWindow?: number; // in minutes\n  threshold?: number;\n}\n\nexport interface AuditAlertAction {\n  type: 'email' | 'webhook' | 'slack' | 'sms' | 'escalation';\n  configuration: unknown;\n  delay?: number; // in minutes\n}\n\nclass AuditLoggerService extends EventEmitter {\n  private events: AuditEvent[] = [];\n  private alerts: Map<string, AuditAlert> = new Map();\n  private prisma: PrismaClient;\n  private encryptionKey: Buffer;\n  private currentBlockNumber = 0;\n  private lastBlockHash = '';\n  private retentionPeriodDays = 2555; // 7 years for healthcare compliance;\n  private cleanupInterval: NodeJS.Timeout;\n  private alertCheckInterval: NodeJS.Timeout;\n\n  constructor() {\n    super();\n    this.prisma = new PrismaClient();\n    \n    // Initialize encryption key (in production, this should be from secure key management)\n    this.encryptionKey = crypto.randomBytes(32);\n    \n    // Initialize blockchain-like integrity system\n    this.initializeIntegrityChain();\n    \n    // Setup cleanup and alert checking\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupOldEvents();\n    }, 24 * 60 * 60 * 1000); // Daily cleanup\n    \n    this.alertCheckInterval = setInterval(() => {\n      this.checkAlertConditions();\n    }, 5 * 60 * 1000); // Check alerts every 5 minutes\n  }\n\n  /**\n   * Log an audit event\n   */\n  async logEvent(\n    eventType: AuditEventType,\n    category: AuditCategory,\n    actor: AuditActor,\n    resource: AuditResource,\n    action: string,\n    details: Omit<AuditDetails, 'description'> & { description?: string },\n    context?: Partial<AuditContext>,\n    severity: AuditSeverity = 'medium',\n    outcome: 'success' | 'failure' | 'pending' = 'success';\n  ): Promise<string> {\n    try {\n      const eventId = uuidv4();\n      const timestamp = new Date();\n      \n      // Determine compliance requirements\n      const compliance = this.determineComplianceInfo(category, resource, action);\n      \n      // Generate integrity information\n      const integrity = await this.generateIntegrityInfo({\n        eventId,\n        timestamp,\n        eventType,\n        actor,\n        resource,\n        action,\n        outcome\n      });\n      \n      const auditEvent: AuditEvent = {\n        id: eventId,\n        timestamp,\n        eventType,\n        category,\n        severity,\n        actor,\n        resource,\n        action,\n        outcome,\n        details: {\n          description: details.description || this.generateDescription(action, resource, outcome),\n          ...details\n        },\n        context: {\n          requestId: uuidv4(),\n          ...context\n        },\n        compliance,\n        integrity\n      };\n      \n      // Store event\n      await this.storeEvent(auditEvent);\n      \n      // Add to in-memory array for fast access\n      this.events.push(auditEvent);\n      \n      // Keep only recent events in memory (last 10000)\n      if (this.events.length > 10000) {\n        this.events = this.events.slice(-5000);\n      }\n      \n      // Emit event for real-time processing\n      this.emit('audit_event', auditEvent);\n      \n      // Check for compliance violations\n      await this.checkComplianceViolations(auditEvent);\n      \n      return eventId;\n    } catch (error) {\n      // Debug logging removed\n      // In case of audit system failure, we should still allow the operation to continue\n      // but log the failure separately\n      this.emit('audit_error', { error, context: { eventType, action, actor: actor.id } });\n      return '';\n    }\n  }\n\n  /**\n   * Log patient data access event\n   */\n  async logPatientDataAccess(\n    actor: AuditActor,\n    patientId: string,\n    dataType: string,\n    action: 'view' | 'export' | 'print' | 'search',\n    context?: Partial<AuditContext>,\n    searchCriteria?: unknown\n  ): Promise<string> {\n    return this.logEvent(;\n      'data_access',\n      'patient_data',\n      actor,\n      {\n        type: 'patient_record',\n        id: patientId,\n        patientId,\n        classification: 'confidential'\n      },\n      `patient_data_${action}`,\n      {\n        description: `Accessed patient ${dataType} data`,\n        searchCriteria,\n        metadata: {\n          dataType,\n          accessMethod: action\n        }\n      },\n      context,\n      'high'\n    );\n  }\n\n  /**\n   * Log clinical data modification\n   */\n  async logClinicalDataModification(\n    actor: AuditActor,\n    resourceType: string,\n    resourceId: string,\n    action: 'create' | 'update' | 'delete',\n    beforeState?: unknown,\n    afterState?: unknown,\n    patientId?: string,\n    context?: Partial<AuditContext>\n  ): Promise<string> {\n    const changedFields = beforeState &&
  afterState;\n      ? this.getChangedFields(beforeState, afterState)\n      : undefined;\n    \n    return this.logEvent(;\n      'data_modification',\n      'clinical_data',\n      actor,\n      {\n        type: resourceType,\n        id: resourceId,\n        patientId,\n        classification: 'confidential'\n      },\n      `${resourceType}_${action}`,\n      {\n        description: `${action.toUpperCase()} ${resourceType}`,\n        beforeState: beforeState ? this.sanitizeForAudit(beforeState) : undefined,\n        afterState: afterState ? this.sanitizeForAudit(afterState) : undefined,\n        changedFields\n      },\n      context,\n      action === 'delete' ? 'high' : 'medium'\n    );\n  }\n\n  /**\n   * Log authentication event\n   */\n  async logAuthentication(\n    actorId: string,\n    action: 'login' | 'logout' | 'failed_login' | 'password_change' | 'account_locked',\n    outcome: 'success' | 'failure',\n    context?: Partial<AuditContext>,\n    details?: unknown\n  ): Promise<string> {\n    return this.logEvent(;\n      'authentication',\n      'security',\n      {\n        type: 'user',\n        id: actorId\n      },\n      {\n        type: 'user_account',\n        id: actorId,\n        classification: 'internal'\n      },\n      action,\n      {\n        description: `User ${action} ${outcome}`,\n        metadata: details\n      },\n      context,\n      outcome === 'failure' ? 'high' : 'medium',\n      outcome\n    );\n  }\n\n  /**\n   * Log security event\n   */\n  async logSecurityEvent(\n    eventType: string,\n    severity: AuditSeverity,\n    actor: AuditActor,\n    details: string,\n    context?: Partial<AuditContext>,\n    metadata?: unknown\n  ): Promise<string> {\n    return this.logEvent(;\n      'security_event',\n      'security',\n      actor,\n      {\n        type: 'security_system',\n        classification: 'restricted'\n      },\n      eventType,\n      {\n        description: details,\n        metadata\n      },\n      context,\n      severity\n    );\n  }\n\n  /**\n   * Query audit events\n   */\n  async queryEvents(query: AuditQuery): Promise<{ events: AuditEvent[]; totalCount: number }> {\n    let filteredEvents = [...this.events];\n    \n    // Apply filters\n    if (query.startDate) {\n      filteredEvents = filteredEvents.filter(e => e.timestamp >= query.startDate!);\n    }\n    if (query.endDate) {\n      filteredEvents = filteredEvents.filter(e => e.timestamp <= query.endDate!);\n    }\n    if (query.eventTypes &&
  query.eventTypes.length > 0) {\n      filteredEvents = filteredEvents.filter(e => query.eventTypes!.includes(e.eventType));\n    }\n    if (query.categories &&
  query.categories.length > 0) {\n      filteredEvents = filteredEvents.filter(e => query.categories!.includes(e.category));\n    }\n    if (query.severities &&
  query.severities.length > 0) {\n      filteredEvents = filteredEvents.filter(e => query.severities!.includes(e.severity));\n    }\n    if (query.actorId) {\n      filteredEvents = filteredEvents.filter(e => e.actor.id === query.actorId);\n    }\n    if (query.actorType) {\n      filteredEvents = filteredEvents.filter(e => e.actor.type === query.actorType);\n    }\n    if (query.resourceType) {\n      filteredEvents = filteredEvents.filter(e => e.resource.type === query.resourceType);\n    }\n    if (query.resourceId) {\n      filteredEvents = filteredEvents.filter(e => e.resource.id === query.resourceId);\n    }\n    if (query.patientId) {\n      filteredEvents = filteredEvents.filter(e => e.resource.patientId === query.patientId);\n    }\n    if (query.organizationId) {\n      filteredEvents = filteredEvents.filter(e => \n        e.actor.organizationId === query.organizationId || \n        e.resource.organizationId === query.organizationId\n      );\n    }\n    if (query.outcome) {\n      filteredEvents = filteredEvents.filter(e => e.outcome === query.outcome);\n    }\n    if (query.searchText) {\n      const searchLower = query.searchText.toLowerCase();\n      filteredEvents = filteredEvents.filter(e => \n        e.details.description.toLowerCase().includes(searchLower) ||\n        e.action.toLowerCase().includes(searchLower) ||\n        e.resource.type.toLowerCase().includes(searchLower)\n      );\n    }\n    \n    const totalCount = filteredEvents.length;\n    \n    // Apply sorting\n    const sortBy = query.sortBy || 'timestamp';\n    const sortOrder = query.sortOrder || 'desc';\n    \n    filteredEvents.sort((a, b) => {\n      let aValue = (a as any)[sortBy];\n      let bValue = (b as any)[sortBy];\n      \n      if (aValue instanceof Date) {\n        aValue = aValue.getTime();\n        bValue = bValue.getTime();\n      }\n      \n      if (sortOrder === 'asc') {\n        return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;\n      } else {\n        return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;\n      }\n    });\n    \n    // Apply pagination\n    const offset = query.offset || 0;\n    const limit = query.limit || 100;\n    const paginatedEvents = filteredEvents.slice(offset, offset + limit);\n    \n    return {\n      events: paginatedEvents,\n      totalCount\n    };\n  }\n\n  /**\n   * Generate audit report\n   */\n  async generateReport(\n    title: string,\n    query: AuditQuery,\n    generatedBy: string,\n    format: 'json' | 'csv' | 'pdf' | 'xml' = 'json';\n  ): Promise<AuditReport> {\n    const { events, totalCount } = await this.queryEvents(query);\n    const statistics = this.generateStatistics(events);\n    const complianceFlags = this.identifyComplianceFlags(events);\n    \n    const report: AuditReport = {\n      id: uuidv4(),\n      title,\n      description: `Audit report generated for ${totalCount} events`,\n      query,\n      events,\n      statistics,\n      generatedAt: new Date(),\n      generatedBy,\n      format,\n      complianceFlags\n    };\n    \n    this.emit('report_generated', report);\n    return report;\n  }\n\n  /**\n   * Create audit alert\n   */\n  async createAlert(\n    name: string,\n    description: string,\n    conditions: AuditAlertCondition[],\n    actions: AuditAlertAction[],\n    severity: AuditSeverity,\n    createdBy: string\n  ): Promise<string> {\n    const alertId = uuidv4();\n    \n    const alert: AuditAlert = {\n      id: alertId,\n      name,\n      description,\n      conditions,\n      actions,\n      isActive: true,\n      severity,\n      createdAt: new Date(),\n      createdBy,\n      triggerCount: 0\n    };\n    \n    this.alerts.set(alertId, alert);\n    this.emit('alert_created', alert);\n    \n    return alertId;\n  }\n\n  /**\n   * Get audit statistics\n   */\n  getStatistics(timeRange?: { start: Date; end: Date }): AuditStatistics {\n    let events = this.events;\n    \n    if (timeRange) {\n      events = events.filter(e => \n        e.timestamp >= timeRange.start &&
  e.timestamp <= timeRange.end;\n      );\n    }\n    \n    return this.generateStatistics(events);\n  }\n\n  /**\n   * Verify audit trail integrity\n   */\n  async verifyIntegrity(startDate?: Date, endDate?: Date): Promise<{\n    isValid: boolean;\n    totalEvents: number;\n    validEvents: number;\n    invalidEvents: number;\n    brokenChain: boolean;\n    details: string[];\n  }> {\n    const query: AuditQuery = {};\n    if (startDate) query.startDate = startDate;\n    if (endDate) query.endDate = endDate;\n    \n    const { events } = await this.queryEvents({ ...query, limit: 10000 });\n    \n    let validEvents = 0;\n    let invalidEvents = 0;\n    const details: string[] = [];\n    let brokenChain = false;\n    let lastHash = '';\n    \n    for (const event of events.sort((a, b) => a.integrity.blockNumber! - b.integrity.blockNumber!)) {\n      // Verify event hash\n      const expectedHash = await this.calculateEventHash(event);\n      if (event.integrity.hash !== expectedHash) {\n        invalidEvents++;\n        details.push(`Event ${event.id} has invalid hash`);\n      } else {\n        validEvents++;\n      }\n      \n      // Verify chain integrity\n      if (lastHash &&
  event.integrity.previousHash !== lastHash) {\n        brokenChain = true;\n        details.push(`Chain broken at event ${event.id}`);\n      }\n      \n      lastHash = event.integrity.hash;\n    }\n    \n    return {\n      isValid: invalidEvents === 0 &&;
  !brokenChain,\n      totalEvents: events.length,\n      validEvents,\n      invalidEvents,\n      brokenChain,\n      details\n    };\n  }\n\n  // Private methods\n\n  private async storeEvent(event: AuditEvent): Promise<void> {\n    try {\n      // In production, this would store to database\n      // For now, we'll just emit an event\n      this.emit('event_stored', event);\n    } catch (error) {\n      // Debug logging removed\n      throw error;\n    }\n  }\n\n  private determineComplianceInfo(category: AuditCategory, resource: AuditResource, action: string): ComplianceInfo {\n    const regulations: ComplianceRegulation[] = [];\n    const dataTypes: string[] = [];\n    let retentionPeriod = this.retentionPeriodDays;\n    let privacyImpact: 'none' | 'low' | 'medium' | 'high' = 'low';\n    \n    // Healthcare data always requires HIPAA compliance\n    if (category === 'patient_data' || category === 'clinical_data') {\n      regulations.push('HIPAA', 'HITECH');\n      dataTypes.push('PHI'); // Protected Health Information\n      privacyImpact = 'high';\n    }\n    \n    // Financial data requires SOX compliance\n    if (category === 'financial_data') {\n      regulations.push('SOX');\n      dataTypes.push('financial');\n      privacyImpact = 'medium';\n    }\n    \n    // EU patients require GDPR compliance\n    if (resource.patientId &&;
  this.isEUPatient(resource.patientId)) {\n      regulations.push('GDPR');\n      dataTypes.push('personal_data');\n    }\n    \n    return {\n      regulations,\n      dataTypes,\n      retentionPeriod,\n      privacyImpact,\n      consentRequired: privacyImpact === 'high',\n      consentStatus: 'granted' // In production, this would be checked\n    };\n  }\n\n  private async generateIntegrityInfo(eventSummary: unknown): Promise<IntegrityInfo> {\n    const hash = await this.calculateEventHash(eventSummary);\n    const blockNumber = ++this.currentBlockNumber;\n    \n    const integrity: IntegrityInfo = {\n      hash,\n      algorithm: 'SHA-256',\n      previousHash: this.lastBlockHash,\n      blockNumber\n    };\n    \n    this.lastBlockHash = hash;\n    return integrity;\n  }\n\n  private async calculateEventHash(event: unknown): Promise<string> {\n    const data = {\n      id: event.id || event.eventId,\n      timestamp: event.timestamp,\n      eventType: event.eventType,\n      actor: event.actor,\n      resource: event.resource,\n      action: event.action,\n      outcome: event.outcome\n    };\n    \n    const dataString = JSON.stringify(data, Object.keys(data).sort());\n    return crypto.createHash('sha256').update(dataString).digest('hex');\n  }\n\n  private generateDescription(action: string, resource: AuditResource, outcome: string): string {\n    const actionMap: Record<string, string> = {\n      'create': 'Created',\n      'read': 'Accessed',\n      'update': 'Modified',\n      'delete': 'Deleted',\n      'login': 'Logged in',\n      'logout': 'Logged out',\n      'search': 'Searched',\n      'export': 'Exported',\n      'print': 'Printed'\n    };\n    \n    const actionText = actionMap[action] || action;\n    const resourceText = resource.name || resource.type;\n    const outcomeText = outcome === 'failure' ? ' (FAILED)' : '';\n    \n    return `${actionText} ${resourceText}${outcomeText}`;\n  }\n\n  private getChangedFields(beforeState: unknown, afterState: unknown): string[] {\n    const changes: string[] = [];\n    const allKeys = new Set([...Object.keys(beforeState), ...Object.keys(afterState)]);\n    \n    for (const key of allKeys) {\n      if (JSON.stringify(beforeState[key]) !== JSON.stringify(afterState[key])) {\n        changes.push(key);\n      }\n    }\n    \n    return changes;\n  }\n\n  private sanitizeForAudit(data: unknown): unknown {\n    // Remove sensitive fields that shouldn't be logged\n    const sensitiveFields = ['password', 'ssn', 'creditCard', 'token', 'secret'];\n    \n    if (typeof data !== 'object' || data === null) {\n      return data;\n    }\n    \n    const sanitized = { ...data };\n    \n    for (const field of sensitiveFields) {\n      if (field in sanitized) {\n        sanitized[field] = '[REDACTED]';\n      }\n    }\n    \n    return sanitized;\n  }\n\n  private isEUPatient(patientId: string): boolean {\n    // In production, this would check patient location/citizenship\n    return false;\n  }\n\n  private async checkComplianceViolations(event: AuditEvent): Promise<void> {\n    // Check for potential compliance violations\n    const violations: string[] = [];\n    \n    // Check for after-hours access to patient data\n    if (event.category === 'patient_data' &&;
  this.isAfterHours(event.timestamp)) {\n      violations.push('after_hours_patient_access');\n    }\n    \n    // Check for bulk data access\n    if (event.details.resultCount &&
  event.details.resultCount > 100) {\n      violations.push('bulk_data_access');\n    }\n    \n    // Check for repeated failed access attempts\n    if (event.outcome === 'failure' &&;
  event.eventType === 'data_access') {\n      const recentFailures = this.events.filter(e => \n        e.actor.id === event.actor.id &&\n        e.outcome === 'failure' &&\n        e.timestamp > new Date(Date.now() - 60 * 60 * 1000) // Last hour\n      ).length;\n      \n      if (recentFailures >= 5) {\n        violations.push('repeated_access_failures');\n      }\n    }\n    \n    if (violations.length > 0) {\n      await this.logSecurityEvent(\n        'compliance_violation',\n        'high',\n        event.actor,\n        `Potential compliance violations detected: ${violations.join(', ')}`,\n        event.context,\n        { originalEvent: event.id, violations }\n      );\n    }\n  }\n\n  private isAfterHours(timestamp: Date): boolean {\n    const hour = timestamp.getHours();\n    return hour < 7 || hour > 19; // Before 7 AM or after 7 PM;\n  }\n\n  private generateStatistics(events: AuditEvent[]): AuditStatistics {\n    const stats: AuditStatistics = {\n      totalEvents: events.length,\n      eventsByType: {},\n      eventsByCategory: {},\n      eventsBySeverity: {},\n      eventsByOutcome: {},\n      uniqueActors: 0,\n      uniqueResources: 0,\n      timeRange: {\n        start: new Date(),\n        end: new Date()\n      },\n      complianceMetrics: {\n        totalPatientDataAccess: 0,\n        unauthorizedAttempts: 0,\n        consentViolations: 0,\n        dataExports: 0\n      }\n    };\n    \n    if (events.length === 0) return stats;\n    \n    // Calculate time range\n    const timestamps = events.map(e => e.timestamp.getTime());\n    stats.timeRange.start = new Date(Math.min(...timestamps));\n    stats.timeRange.end = new Date(Math.max(...timestamps));\n    \n    // Count unique actors and resources\n    const uniqueActors = new Set(events.map(e => e.actor.id));\n    const uniqueResources = new Set(events.map(e => `${e.resource.type}:${e.resource.id}`));\n    stats.uniqueActors = uniqueActors.size;\n    stats.uniqueResources = uniqueResources.size;\n    \n    // Group by various dimensions\n    for (const event of events) {\n      // By type\n      stats.eventsByType[event.eventType] = (stats.eventsByType[event.eventType] || 0) + 1;\n      \n      // By category\n      stats.eventsByCategory[event.category] = (stats.eventsByCategory[event.category] || 0) + 1;\n      \n      // By severity\n      stats.eventsBySeverity[event.severity] = (stats.eventsBySeverity[event.severity] || 0) + 1;\n      \n      // By outcome\n      stats.eventsByOutcome[event.outcome] = (stats.eventsByOutcome[event.outcome] || 0) + 1;\n      \n      // Compliance metrics\n      if (event.category === 'patient_data') {\n        stats.complianceMetrics.totalPatientDataAccess++;\n      }\n      \n      if (event.outcome === 'failure' &&
  event.eventType === 'data_access') {\n        stats.complianceMetrics.unauthorizedAttempts++;\n      }\n      \n      if (event.action.includes('export')) {\n        stats.complianceMetrics.dataExports++;\n      }\n      \n      if (event.compliance.consentStatus === 'denied' || event.compliance.consentStatus === 'withdrawn') {\n        stats.complianceMetrics.consentViolations++;\n      }\n    }\n    \n    return stats;\n  }\n\n  private identifyComplianceFlags(events: AuditEvent[]): string[] {\n    const flags: string[] = [];\n    \n    // Check for high-risk patterns\n    const patientDataAccess = events.filter(e => e.category === 'patient_data').length;\n    if (patientDataAccess > 1000) {\n      flags.push('high_volume_patient_data_access');\n    }\n    \n    const failedAccess = events.filter(e => e.outcome === 'failure').length;\n    if (failedAccess > 50) {\n      flags.push('high_failed_access_attempts');\n    }\n    \n    const afterHoursAccess = events.filter(e => \n      e.category === 'patient_data' &&
  this.isAfterHours(e.timestamp)\n    ).length;\n    if (afterHoursAccess > 10) {\n      flags.push('significant_after_hours_access');\n    }\n    \n    return flags;\n  }\n\n  private async checkAlertConditions(): Promise<void> {\n    const now = new Date();\n    \n    for (const alert of this.alerts.values()) {\n      if (!alert.isActive) continue;\n      \n      const shouldTrigger = await this.evaluateAlertConditions(alert, now);\n      if (shouldTrigger) {\n        await this.triggerAlert(alert);\n      }\n    }\n  }\n\n  private async evaluateAlertConditions(alert: AuditAlert, now: Date): Promise<boolean> {\n    for (const condition of alert.conditions) {\n      const timeWindow = condition.timeWindow || 60; // Default 1 hour;\n      const startTime = new Date(now.getTime() - timeWindow * 60 * 1000);\n      \n      const relevantEvents = this.events.filter(e => e.timestamp >= startTime);\n      \n      // Evaluate condition based on field\n      let value: unknown;\n      switch (condition.field) {\n        case 'event_count':\n          value = relevantEvents.length;\n          break;\n        case 'failure_rate':\n          const failures = relevantEvents.filter(e => e.outcome === 'failure').length;\n          value = relevantEvents.length > 0 ? (failures / relevantEvents.length) * 100 : 0;\n          break;\n        case 'unique_actors':\n          value = new Set(relevantEvents.map(e => e.actor.id)).size;\n          break;\n        default:\n          continue;\n      }\n      \n      // Check if condition is met\n      const conditionMet = this.evaluateCondition(value, condition.operator, condition.value);\n      if (!conditionMet) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  private evaluateCondition(value: unknown, operator: string, expectedValue: unknown): boolean {\n    switch (operator) {\n      case 'equals': return value === expectedValue;\n      case 'not_equals': return value !== expectedValue;\n      case 'greater_than': return value > expectedValue;\n      case 'less_than': return value < expectedValue;\n      case 'contains': return String(value).includes(String(expectedValue));\n      case 'in': return Array.isArray(expectedValue) &&
  expectedValue.includes(value);\n      case 'not_in': return Array.isArray(expectedValue) &&;
  !expectedValue.includes(value);\n      default: return false;\n    }\n  }\n\n  private async triggerAlert(alert: AuditAlert): Promise<void> {\n    alert.lastTriggered = new Date();\n    alert.triggerCount++;\n    \n    this.emit('alert_triggered', alert);\n    \n    // Execute alert actions\n    for (const action of alert.actions) {\n      try {\n        await this.executeAlertAction(action, alert);\n      } catch (error) {\n        // Debug logging removed\n      }\n    }\n  }\n\n  private async executeAlertAction(action: AuditAlertAction, alert: AuditAlert): Promise<void> {\n    switch (action.type) {\n      case 'email':\n        // RESOLVED: (Priority: Medium, Target: Next Sprint): \1 - Automated quality improvement;