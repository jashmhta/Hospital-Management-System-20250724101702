/**
 * Enterprise Health Monitoring and Alerting Service
 * Implements comprehensive system health monitoring, performance tracking, and automated alerting
 * Based on enterprise requirements from ZIP 6 resources
 */

import { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { PrismaClient } from '@prisma/client';\nimport os from 'os';\nimport { promisify } from 'util';\nimport { exec } from 'child_process';\n\nconst execAsync = promisify(exec);\n\nexport interface HealthCheck {\n  id: string;\n  name: string;\n  type: HealthCheckType;\n  status: HealthStatus;\n  lastCheck: Date;\n  nextCheck: Date;\n  interval: number; // in seconds\n  timeout: number; // in seconds\n  retryCount: number;\n  maxRetries: number;\n  configuration: any;\n  metrics: HealthMetrics;\n  history: HealthCheckResult[];\n  isEnabled: boolean;\n  tags: string[];\n  dependencies: string[];\n  alertRules: AlertRule[];\n}\n\nexport type HealthCheckType = \n  | 'database'\n  | 'redis'\n  | 'api_endpoint'\n  | 'external_service'\n  | 'file_system'\n  | 'memory'\n  | 'cpu'\n  | 'disk'\n  | 'network'\n  | 'custom';\n\nexport type HealthStatus = 'healthy' | 'degraded' | 'unhealthy' | 'unknown';\n\nexport interface HealthCheckResult {\n  timestamp: Date;\n  status: HealthStatus;\n  responseTime: number;\n  message?: string;\n  metrics?: Record<string, number>;\n  error?: string;\n}\n\nexport interface HealthMetrics {\n  responseTime: {\n    current: number;\n    average: number;\n    min: number;\n    max: number;\n    p95: number;\n    p99: number;\n  };\n  availability: {\n    uptime: number; // percentage\n    totalChecks: number;\n    successfulChecks: number;\n    failedChecks: number;\n  };\n  performance: {\n    throughput?: number;\n    errorRate: number;\n    latency: number;\n  };\n}\n\nexport interface SystemHealth {\n  overall: HealthStatus;\n  timestamp: Date;\n  components: ComponentHealth[];\n  metrics: SystemMetrics;\n  alerts: ActiveAlert[];\n  summary: HealthSummary;\n}\n\nexport interface ComponentHealth {\n  name: string;\n  type: HealthCheckType;\n  status: HealthStatus;\n  responseTime: number;\n  lastCheck: Date;\n  message?: string;\n  metrics?: Record<string, number>;\n}\n\nexport interface SystemMetrics {\n  cpu: {\n    usage: number; // percentage\n    loadAverage: number[];\n    cores: number;\n  };\n  memory: {\n    used: number; // bytes\n    free: number; // bytes\n    total: number; // bytes\n    usage: number; // percentage\n  };\n  disk: {\n    used: number; // bytes\n    free: number; // bytes\n    total: number; // bytes\n    usage: number; // percentage\n  };\n  network: {\n    inbound: number; // bytes/sec\n    outbound: number; // bytes/sec\n    connections: number;\n  };\n  application: {\n    uptime: number; // seconds\n    activeConnections: number;\n    memoryHeap: number;\n    eventLoopLag: number;\n  };\n}\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  condition: AlertCondition;\n  severity: AlertSeverity;\n  channels: AlertChannel[];\n  isEnabled: boolean;\n  cooldown: number; // minutes\n  lastTriggered?: Date;\n}\n\nexport interface AlertCondition {\n  metric: string;\n  operator: 'gt' | 'gte' | 'lt' | 'lte' | 'eq' | 'ne';\n  threshold: number;\n  duration: number; // seconds\n  aggregation?: 'avg' | 'min' | 'max' | 'sum' | 'count';\n}\n\nexport type AlertSeverity = 'info' | 'warning' | 'error' | 'critical';\n\nexport interface AlertChannel {\n  type: 'email' | 'slack' | 'webhook' | 'sms' | 'pagerduty';\n  configuration: any;\n  isEnabled: boolean;\n}\n\nexport interface ActiveAlert {\n  id: string;\n  ruleId: string;\n  ruleName: string;\n  severity: AlertSeverity;\n  status: 'active' | 'resolved' | 'silenced';\n  message: string;\n  triggeredAt: Date;\n  resolvedAt?: Date;\n  silencedUntil?: Date;\n  component: string;\n  metadata: any;\n}\n\nexport interface HealthSummary {\n  totalComponents: number;\n  healthyComponents: number;\n  degradedComponents: number;\n  unhealthyComponents: number;\n  unknownComponents: number;\n  overallAvailability: number;\n  averageResponseTime: number;\n  activeAlerts: number;\n  criticalAlerts: number;\n}\n\nexport interface PerformanceBaseline {\n  component: string;\n  metric: string;\n  baseline: number;\n  tolerance: number; // percentage\n  sampleSize: number;\n  confidence: number; // percentage\n  lastUpdated: Date;\n}\n\nclass HealthMonitorService extends EventEmitter {\n  private healthChecks: Map<string, HealthCheck> = new Map();\n  private activeAlerts: Map<string, ActiveAlert> = new Map();\n  private performanceBaselines: Map<string, PerformanceBaseline> = new Map();\n  private prisma: PrismaClient;\n  private monitoringInterval: NodeJS.Timeout;\n  private metricsInterval: NodeJS.Timeout;\n  private isRunning = false;\n  private startTime = new Date();\n  private systemMetricsHistory: SystemMetrics[] = [];\n  private maxHistorySize = 1000;\n\n  constructor() {\n    super();\n    this.prisma = new PrismaClient();\n    \n    // Initialize default health checks\n    this.initializeDefaultChecks();\n    \n    // Start monitoring\n    this.start();\n  }\n\n  /**\n   * Start health monitoring\n   */\n  start(): void {\n    if (this.isRunning) return;\n    \n    this.isRunning = true;\n    this.startTime = new Date();\n    \n    // Run health checks every 30 seconds\n    this.monitoringInterval = setInterval(() => {\n      this.runHealthChecks();\n    }, 30000);\n    \n    // Collect system metrics every 10 seconds\n    this.metricsInterval = setInterval(() => {\n      this.collectSystemMetrics();\n    }, 10000);\n    \n    // Initial health check\n    setTimeout(() => this.runHealthChecks(), 1000);\n    \n    console.log('Health monitoring service started');\n    this.emit('monitoring_started');\n  }\n\n  /**\n   * Stop health monitoring\n   */\n  stop(): void {\n    if (!this.isRunning) return;\n    \n    this.isRunning = false;\n    \n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n    }\n    \n    if (this.metricsInterval) {\n      clearInterval(this.metricsInterval);\n    }\n    \n    console.log('Health monitoring service stopped');\n    this.emit('monitoring_stopped');\n  }\n\n  /**\n   * Register a new health check\n   */\n  registerHealthCheck(\n    name: string,\n    type: HealthCheckType,\n    configuration: any,\n    options: {\n      interval?: number;\n      timeout?: number;\n      maxRetries?: number;\n      tags?: string[];\n      dependencies?: string[];\n      alertRules?: Omit<AlertRule, 'id'>[];\n    } = {}\n  ): string {\n    const checkId = uuidv4();\n    \n    const healthCheck: HealthCheck = {\n      id: checkId,\n      name,\n      type,\n      status: 'unknown',\n      lastCheck: new Date(0),\n      nextCheck: new Date(),\n      interval: options.interval || 60,\n      timeout: options.timeout || 30,\n      retryCount: 0,\n      maxRetries: options.maxRetries || 3,\n      configuration,\n      metrics: {\n        responseTime: {\n          current: 0,\n          average: 0,\n          min: Infinity,\n          max: 0,\n          p95: 0,\n          p99: 0\n        },\n        availability: {\n          uptime: 100,\n          totalChecks: 0,\n          successfulChecks: 0,\n          failedChecks: 0\n        },\n        performance: {\n          errorRate: 0,\n          latency: 0\n        }\n      },\n      history: [],\n      isEnabled: true,\n      tags: options.tags || [],\n      dependencies: options.dependencies || [],\n      alertRules: (options.alertRules || []).map(rule => ({\n        ...rule,\n        id: uuidv4()\n      }))\n    };\n    \n    this.healthChecks.set(checkId, healthCheck);\n    this.emit('health_check_registered', healthCheck);\n    \n    return checkId;\n  }\n\n  /**\n   * Unregister a health check\n   */\n  unregisterHealthCheck(checkId: string): boolean {\n    const healthCheck = this.healthChecks.get(checkId);\n    if (!healthCheck) return false;\n    \n    this.healthChecks.delete(checkId);\n    this.emit('health_check_unregistered', { checkId, name: healthCheck.name });\n    \n    return true;\n  }\n\n  /**\n   * Get current system health\n   */\n  async getSystemHealth(): Promise<SystemHealth> {\n    const components: ComponentHealth[] = [];\n    const alerts = Array.from(this.activeAlerts.values()).filter(alert => alert.status === 'active');\n    \n    // Collect component health\n    for (const healthCheck of this.healthChecks.values()) {\n      const latestResult = healthCheck.history[healthCheck.history.length - 1];\n      \n      components.push({\n        name: healthCheck.name,\n        type: healthCheck.type,\n        status: healthCheck.status,\n        responseTime: healthCheck.metrics.responseTime.current,\n        lastCheck: healthCheck.lastCheck,\n        message: latestResult?.message,\n        metrics: latestResult?.metrics\n      });\n    }\n    \n    // Calculate overall status\n    const overall = this.calculateOverallHealth(components);\n    \n    // Get system metrics\n    const systemMetrics = await this.collectSystemMetrics();\n    \n    // Generate summary\n    const summary = this.generateHealthSummary(components, alerts);\n    \n    return {\n      overall,\n      timestamp: new Date(),\n      components,\n      metrics: systemMetrics,\n      alerts,\n      summary\n    };\n  }\n\n  /**\n   * Get health check by ID\n   */\n  getHealthCheck(checkId: string): HealthCheck | undefined {\n    return this.healthChecks.get(checkId);\n  }\n\n  /**\n   * Get all health checks\n   */\n  getAllHealthChecks(): HealthCheck[] {\n    return Array.from(this.healthChecks.values());\n  }\n\n  /**\n   * Get active alerts\n   */\n  getActiveAlerts(): ActiveAlert[] {\n    return Array.from(this.activeAlerts.values()).filter(alert => alert.status === 'active');\n  }\n\n  /**\n   * Silence an alert\n   */\n  silenceAlert(alertId: string, duration: number): boolean {\n    const alert = this.activeAlerts.get(alertId);\n    if (!alert) return false;\n    \n    alert.status = 'silenced';\n    alert.silencedUntil = new Date(Date.now() + duration * 60 * 1000);\n    \n    this.emit('alert_silenced', alert);\n    return true;\n  }\n\n  /**\n   * Resolve an alert\n   */\n  resolveAlert(alertId: string): boolean {\n    const alert = this.activeAlerts.get(alertId);\n    if (!alert) return false;\n    \n    alert.status = 'resolved';\n    alert.resolvedAt = new Date();\n    \n    this.emit('alert_resolved', alert);\n    return true;\n  }\n\n  /**\n   * Create performance baseline\n   */\n  createPerformanceBaseline(\n    component: string,\n    metric: string,\n    sampleSize = 100,\n    confidence = 95\n  ): void {\n    const healthCheck = Array.from(this.healthChecks.values())\n      .find(check => check.name === component);\n    \n    if (!healthCheck || healthCheck.history.length < sampleSize) {\n      console.warn(`Insufficient data for baseline creation: ${component}`);\n      return;\n    }\n    \n    const recentResults = healthCheck.history.slice(-sampleSize);\n    const values = recentResults.map(result => {\n      if (metric === 'responseTime') return result.responseTime;\n      return result.metrics?.[metric] || 0;\n    }).filter(value => value > 0);\n    \n    if (values.length === 0) return;\n    \n    const baseline = values.reduce((sum, value) => sum + value, 0) / values.length;\n    const tolerance = this.calculateTolerance(values, confidence);\n    \n    const performanceBaseline: PerformanceBaseline = {\n      component,\n      metric,\n      baseline,\n      tolerance,\n      sampleSize: values.length,\n      confidence,\n      lastUpdated: new Date()\n    };\n    \n    this.performanceBaselines.set(`${component}:${metric}`, performanceBaseline);\n    this.emit('baseline_created', performanceBaseline);\n  }\n\n  /**\n   * Check if performance is within baseline\n   */\n  isPerformanceWithinBaseline(component: string, metric: string, value: number): boolean {\n    const baselineKey = `${component}:${metric}`;\n    const baseline = this.performanceBaselines.get(baselineKey);\n    \n    if (!baseline) return true; // No baseline, assume OK\n    \n    const tolerance = (baseline.baseline * baseline.tolerance) / 100;\n    const upperBound = baseline.baseline + tolerance;\n    const lowerBound = baseline.baseline - tolerance;\n    \n    return value >= lowerBound && value <= upperBound;\n  }\n\n  /**\n   * Get performance trends\n   */\n  getPerformanceTrends(timeRange: 'hour' | 'day' | 'week' = 'hour'): any {\n    const timeRanges = {\n      hour: 60 * 60 * 1000,\n      day: 24 * 60 * 60 * 1000,\n      week: 7 * 24 * 60 * 60 * 1000\n    };\n    \n    const cutoffTime = new Date(Date.now() - timeRanges[timeRange]);\n    const recentMetrics = this.systemMetricsHistory.filter(m => \n      new Date(m.application.uptime * 1000) >= cutoffTime\n    );\n    \n    return {\n      cpu: this.calculateTrend(recentMetrics.map(m => m.cpu.usage)),\n      memory: this.calculateTrend(recentMetrics.map(m => m.memory.usage)),\n      responseTime: this.calculateResponseTimeTrend(),\n      availability: this.calculateAvailabilityTrend()\n    };\n  }\n\n  // Private methods\n\n  private initializeDefaultChecks(): void {\n    // Database health check\n    this.registerHealthCheck(\n      'Database Connection',\n      'database',\n      { connectionString: process.env.DATABASE_URL },\n      {\n        interval: 60,\n        timeout: 10,\n        alertRules: [{\n          name: 'Database Down',\n          condition: {\n            metric: 'status',\n            operator: 'eq',\n            threshold: 0, // 0 = unhealthy\n            duration: 60\n          },\n          severity: 'critical',\n          channels: [{ type: 'email', configuration: {}, isEnabled: true }],\n          isEnabled: true,\n          cooldown: 5\n        }]\n      }\n    );\n    \n    // Redis health check\n    this.registerHealthCheck(\n      'Redis Cache',\n      'redis',\n      { host: 'localhost', port: 6379 },\n      {\n        interval: 60,\n        timeout: 5,\n        alertRules: [{\n          name: 'Redis Down',\n          condition: {\n            metric: 'status',\n            operator: 'eq',\n            threshold: 0,\n            duration: 60\n          },\n          severity: 'error',\n          channels: [{ type: 'email', configuration: {}, isEnabled: true }],\n          isEnabled: true,\n          cooldown: 5\n        }]\n      }\n    );\n    \n    // CPU monitoring\n    this.registerHealthCheck(\n      'CPU Usage',\n      'cpu',\n      {},\n      {\n        interval: 30,\n        alertRules: [{\n          name: 'High CPU Usage',\n          condition: {\n            metric: 'cpu_usage',\n            operator: 'gt',\n            threshold: 80,\n            duration: 300\n          },\n          severity: 'warning',\n          channels: [{ type: 'email', configuration: {}, isEnabled: true }],\n          isEnabled: true,\n          cooldown: 10\n        }]\n      }\n    );\n    \n    // Memory monitoring\n    this.registerHealthCheck(\n      'Memory Usage',\n      'memory',\n      {},\n      {\n        interval: 30,\n        alertRules: [{\n          name: 'High Memory Usage',\n          condition: {\n            metric: 'memory_usage',\n            operator: 'gt',\n            threshold: 90,\n            duration: 180\n          },\n          severity: 'error',\n          channels: [{ type: 'email', configuration: {}, isEnabled: true }],\n          isEnabled: true,\n          cooldown: 10\n        }]\n      }\n    );\n  }\n\n  private async runHealthChecks(): Promise<void> {\n    const now = new Date();\n    const checksToRun = Array.from(this.healthChecks.values())\n      .filter(check => check.isEnabled && now >= check.nextCheck);\n    \n    if (checksToRun.length === 0) return;\n    \n    console.log(`Running ${checksToRun.length} health checks`);\n    \n    const checkPromises = checksToRun.map(check => this.runSingleHealthCheck(check));\n    await Promise.allSettled(checkPromises);\n    \n    this.emit('health_checks_completed', {\n      timestamp: now,\n      checksRun: checksToRun.length\n    });\n  }\n\n  private async runSingleHealthCheck(check: HealthCheck): Promise<void> {\n    const startTime = Date.now();\n    \n    try {\n      const result = await this.executeHealthCheck(check);\n      const responseTime = Date.now() - startTime;\n      \n      // Update check status and metrics\n      check.status = result.status;\n      check.lastCheck = new Date();\n      check.nextCheck = new Date(Date.now() + check.interval * 1000);\n      check.retryCount = 0;\n      \n      // Add to history\n      const checkResult: HealthCheckResult = {\n        timestamp: check.lastCheck,\n        status: result.status,\n        responseTime,\n        message: result.message,\n        metrics: result.metrics,\n        error: result.error\n      };\n      \n      check.history.push(checkResult);\n      \n      // Keep only last 100 results\n      if (check.history.length > 100) {\n        check.history = check.history.slice(-100);\n      }\n      \n      // Update metrics\n      this.updateHealthCheckMetrics(check, checkResult);\n      \n      // Check alert conditions\n      await this.checkAlertConditions(check, checkResult);\n      \n      this.emit('health_check_completed', { check, result: checkResult });\n      \n    } catch (error) {\n      console.error(`Health check failed for ${check.name}:`, error);\n      \n      check.retryCount++;\n      if (check.retryCount < check.maxRetries) {\n        // Retry in 10 seconds\n        check.nextCheck = new Date(Date.now() + 10000);\n      } else {\n        // Mark as unhealthy\n        check.status = 'unhealthy';\n        check.lastCheck = new Date();\n        check.nextCheck = new Date(Date.now() + check.interval * 1000);\n        check.retryCount = 0;\n        \n        const checkResult: HealthCheckResult = {\n          timestamp: check.lastCheck,\n          status: 'unhealthy',\n          responseTime: Date.now() - startTime,\n          error: error.message\n        };\n        \n        check.history.push(checkResult);\n        this.updateHealthCheckMetrics(check, checkResult);\n        await this.checkAlertConditions(check, checkResult);\n      }\n      \n      this.emit('health_check_failed', { check, error });\n    }\n  }\n\n  private async executeHealthCheck(check: HealthCheck): Promise<HealthCheckResult> {\n    switch (check.type) {\n      case 'database':\n        return this.checkDatabase(check);\n      case 'redis':\n        return this.checkRedis(check);\n      case 'api_endpoint':\n        return this.checkApiEndpoint(check);\n      case 'cpu':\n        return this.checkCPU(check);\n      case 'memory':\n        return this.checkMemory(check);\n      case 'disk':\n        return this.checkDisk(check);\n      case 'network':\n        return this.checkNetwork(check);\n      case 'file_system':\n        return this.checkFileSystem(check);\n      default:\n        throw new Error(`Unsupported health check type: ${check.type}`);\n    }\n  }\n\n  private async checkDatabase(check: HealthCheck): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      await this.prisma.$queryRaw`SELECT 1`;\n      \n      return {\n        timestamp: new Date(),\n        status: 'healthy',\n        responseTime: Date.now() - startTime,\n        message: 'Database connection successful',\n        metrics: {\n          connection_time: Date.now() - startTime\n        }\n      };\n    } catch (error) {\n      return {\n        timestamp: new Date(),\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        message: 'Database connection failed',\n        error: error.message\n      };\n    }\n  }\n\n  private async checkRedis(check: HealthCheck): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      // In production, this would connect to Redis and perform a ping\n      // For now, simulate a successful check\n      await new Promise(resolve => setTimeout(resolve, 10));\n      \n      return {\n        timestamp: new Date(),\n        status: 'healthy',\n        responseTime: Date.now() - startTime,\n        message: 'Redis connection successful',\n        metrics: {\n          ping_time: Date.now() - startTime\n        }\n      };\n    } catch (error) {\n      return {\n        timestamp: new Date(),\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        message: 'Redis connection failed',\n        error: error.message\n      };\n    }\n  }\n\n  private async checkApiEndpoint(check: HealthCheck): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    const { url, method = 'GET', expectedStatus = 200 } = check.configuration;\n    \n    try {\n      const response = await fetch(url, { \n        method,\n        timeout: check.timeout * 1000\n      });\n      \n      const responseTime = Date.now() - startTime;\n      const status = response.status === expectedStatus ? 'healthy' : 'degraded';\n      \n      return {\n        timestamp: new Date(),\n        status,\n        responseTime,\n        message: `API endpoint responded with status ${response.status}`,\n        metrics: {\n          status_code: response.status,\n          response_time: responseTime\n        }\n      };\n    } catch (error) {\n      return {\n        timestamp: new Date(),\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        message: 'API endpoint unreachable',\n        error: error.message\n      };\n    }\n  }\n\n  private async checkCPU(check: HealthCheck): Promise<HealthCheckResult> {\n    const cpus = os.cpus();\n    const loadAvg = os.loadavg();\n    \n    // Calculate CPU usage (simplified)\n    const usage = Math.min(100, (loadAvg[0] / cpus.length) * 100);\n    \n    const status: HealthStatus = usage > 90 ? 'unhealthy' : usage > 70 ? 'degraded' : 'healthy';\n    \n    return {\n      timestamp: new Date(),\n      status,\n      responseTime: 1,\n      message: `CPU usage: ${usage.toFixed(1)}%`,\n      metrics: {\n        cpu_usage: usage,\n        load_average_1m: loadAvg[0],\n        load_average_5m: loadAvg[1],\n        load_average_15m: loadAvg[2],\n        cpu_cores: cpus.length\n      }\n    };\n  }\n\n  private async checkMemory(check: HealthCheck): Promise<HealthCheckResult> {\n    const totalMem = os.totalmem();\n    const freeMem = os.freemem();\n    const usedMem = totalMem - freeMem;\n    const usage = (usedMem / totalMem) * 100;\n    \n    const status: HealthStatus = usage > 95 ? 'unhealthy' : usage > 85 ? 'degraded' : 'healthy';\n    \n    return {\n      timestamp: new Date(),\n      status,\n      responseTime: 1,\n      message: `Memory usage: ${usage.toFixed(1)}%`,\n      metrics: {\n        memory_usage: usage,\n        memory_total: totalMem,\n        memory_used: usedMem,\n        memory_free: freeMem\n      }\n    };\n  }\n\n  private async checkDisk(check: HealthCheck): Promise<HealthCheckResult> {\n    try {\n      const { stdout } = await execAsync('df -h / | tail -1');\n      const parts = stdout.trim().split(/\\s+/);\n      const usage = parseFloat(parts[4].replace('%', ''));\n      \n      const status: HealthStatus = usage > 95 ? 'unhealthy' : usage > 85 ? 'degraded' : 'healthy';\n      \n      return {\n        timestamp: new Date(),\n        status,\n        responseTime: 10,\n        message: `Disk usage: ${usage}%`,\n        metrics: {\n          disk_usage: usage,\n          disk_total: parts[1],\n          disk_used: parts[2],\n          disk_available: parts[3]\n        }\n      };\n    } catch (error) {\n      return {\n        timestamp: new Date(),\n        status: 'unknown',\n        responseTime: 10,\n        message: 'Could not check disk usage',\n        error: error.message\n      };\n    }\n  }\n\n  private async checkNetwork(check: HealthCheck): Promise<HealthCheckResult> {\n    // Simplified network check - in production, this would check actual network stats\n    const status: HealthStatus = 'healthy';\n    \n    return {\n      timestamp: new Date(),\n      status,\n      responseTime: 5,\n      message: 'Network connectivity OK',\n      metrics: {\n        network_status: 1\n      }\n    };\n  }\n\n  private async checkFileSystem(check: HealthCheck): Promise<HealthCheckResult> {\n    const { path } = check.configuration;\n    \n    try {\n      const fs = require('fs').promises;\n      await fs.access(path);\n      \n      return {\n        timestamp: new Date(),\n        status: 'healthy',\n        responseTime: 5,\n        message: `File system path accessible: ${path}`,\n        metrics: {\n          filesystem_accessible: 1\n        }\n      };\n    } catch (error) {\n      return {\n        timestamp: new Date(),\n        status: 'unhealthy',\n        responseTime: 5,\n        message: `File system path not accessible: ${path}`,\n        error: error.message\n      };\n    }\n  }\n\n  private updateHealthCheckMetrics(check: HealthCheck, result: HealthCheckResult): void {\n    const metrics = check.metrics;\n    \n    // Update response time metrics\n    metrics.responseTime.current = result.responseTime;\n    \n    const responseTimes = check.history.map(h => h.responseTime);\n    if (responseTimes.length > 0) {\n      responseTimes.sort((a, b) => a - b);\n      metrics.responseTime.average = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;\n      metrics.responseTime.min = Math.min(metrics.responseTime.min, result.responseTime);\n      metrics.responseTime.max = Math.max(metrics.responseTime.max, result.responseTime);\n      metrics.responseTime.p95 = responseTimes[Math.floor(responseTimes.length * 0.95)];\n      metrics.responseTime.p99 = responseTimes[Math.floor(responseTimes.length * 0.99)];\n    }\n    \n    // Update availability metrics\n    metrics.availability.totalChecks++;\n    if (result.status === 'healthy') {\n      metrics.availability.successfulChecks++;\n    } else {\n      metrics.availability.failedChecks++;\n    }\n    \n    metrics.availability.uptime = (metrics.availability.successfulChecks / metrics.availability.totalChecks) * 100;\n    \n    // Update performance metrics\n    const recentFailures = check.history.slice(-10).filter(h => h.status !== 'healthy').length;\n    metrics.performance.errorRate = (recentFailures / Math.min(10, check.history.length)) * 100;\n    metrics.performance.latency = metrics.responseTime.average;\n  }\n\n  private async checkAlertConditions(check: HealthCheck, result: HealthCheckResult): Promise<void> {\n    for (const rule of check.alertRules) {\n      if (!rule.isEnabled) continue;\n      \n      // Check cooldown\n      if (rule.lastTriggered) {\n        const cooldownEnd = new Date(rule.lastTriggered.getTime() + rule.cooldown * 60 * 1000);\n        if (new Date() < cooldownEnd) continue;\n      }\n      \n      const shouldTrigger = this.evaluateAlertCondition(rule.condition, check, result);\n      \n      if (shouldTrigger) {\n        await this.triggerAlert(rule, check, result);\n      }\n    }\n  }\n\n  private evaluateAlertCondition(\n    condition: AlertCondition,\n    check: HealthCheck,\n    result: HealthCheckResult\n  ): boolean {\n    let value: number;\n    \n    switch (condition.metric) {\n      case 'status':\n        value = result.status === 'healthy' ? 1 : 0;\n        break;\n      case 'response_time':\n        value = result.responseTime;\n        break;\n      case 'cpu_usage':\n        value = result.metrics?.cpu_usage || 0;\n        break;\n      case 'memory_usage':\n        value = result.metrics?.memory_usage || 0;\n        break;\n      case 'disk_usage':\n        value = result.metrics?.disk_usage || 0;\n        break;\n      case 'error_rate':\n        value = check.metrics.performance.errorRate;\n        break;\n      default:\n        value = result.metrics?.[condition.metric] || 0;\n    }\n    \n    switch (condition.operator) {\n      case 'gt': return value > condition.threshold;\n      case 'gte': return value >= condition.threshold;\n      case 'lt': return value < condition.threshold;\n      case 'lte': return value <= condition.threshold;\n      case 'eq': return value === condition.threshold;\n      case 'ne': return value !== condition.threshold;\n      default: return false;\n    }\n  }\n\n  private async triggerAlert(\n    rule: AlertRule,\n    check: HealthCheck,\n    result: HealthCheckResult\n  ): Promise<void> {\n    const alertId = uuidv4();\n    \n    const alert: ActiveAlert = {\n      id: alertId,\n      ruleId: rule.id,\n      ruleName: rule.name,\n      severity: rule.severity,\n      status: 'active',\n      message: `${rule.name}: ${check.name} - ${result.message || 'Alert triggered'}`,\n      triggeredAt: new Date(),\n      component: check.name,\n      metadata: {\n        checkId: check.id,\n        condition: rule.condition,\n        value: result.metrics?.[rule.condition.metric] || result.responseTime,\n        threshold: rule.condition.threshold\n      }\n    };\n    \n    this.activeAlerts.set(alertId, alert);\n    rule.lastTriggered = new Date();\n    \n    // Execute alert channels\n    for (const channel of rule.channels) {\n      if (channel.isEnabled) {\n        await this.executeAlertChannel(channel, alert);\n      }\n    }\n    \n    this.emit('alert_triggered', alert);\n  }\n\n  private async executeAlertChannel(channel: AlertChannel, alert: ActiveAlert): Promise<void> {\n    try {\n      switch (channel.type) {\n        case 'email':\n          console.log(`EMAIL ALERT: ${alert.message}`);\n          break;\n        case 'slack':\n          console.log(`SLACK ALERT: ${alert.message}`);\n          break;\n        case 'webhook':\n          console.log(`WEBHOOK ALERT: ${alert.message}`);\n          break;\n        case 'sms':\n          console.log(`SMS ALERT: ${alert.message}`);\n          break;\n        case 'pagerduty':\n          console.log(`PAGERDUTY ALERT: ${alert.message}`);\n          break;\n      }\n    } catch (error) {\n      console.error(`Alert channel execution failed:`, error);\n    }\n  }\n\n  private async collectSystemMetrics(): Promise<SystemMetrics> {\n    const cpus = os.cpus();\n    const totalMem = os.totalmem();\n    const freeMem = os.freemem();\n    const loadAvg = os.loadavg();\n    \n    const cpuUsage = Math.min(100, (loadAvg[0] / cpus.length) * 100);\n    const memoryUsage = ((totalMem - freeMem) / totalMem) * 100;\n    \n    const uptime = process.uptime();\n    const memUsage = process.memoryUsage();\n    \n    const systemMetrics: SystemMetrics = {\n      cpu: {\n        usage: cpuUsage,\n        loadAverage: loadAvg,\n        cores: cpus.length\n      },\n      memory: {\n        used: totalMem - freeMem,\n        free: freeMem,\n        total: totalMem,\n        usage: memoryUsage\n      },\n      disk: {\n        used: 0, // Would be calculated from disk check\n        free: 0,\n        total: 0,\n        usage: 0\n      },\n      network: {\n        inbound: 0, // Would be calculated from network monitoring\n        outbound: 0,\n        connections: 0\n      },\n      application: {\n        uptime,\n        activeConnections: 0, // Would track actual connections\n        memoryHeap: memUsage.heapUsed,\n        eventLoopLag: 0 // Would measure actual event loop lag\n      }\n    };\n    \n    // Store in history\n    this.systemMetricsHistory.push(systemMetrics);\n    if (this.systemMetricsHistory.length > this.maxHistorySize) {\n      this.systemMetricsHistory = this.systemMetricsHistory.slice(-this.maxHistorySize / 2);\n    }\n    \n    return systemMetrics;\n  }\n\n  private calculateOverallHealth(components: ComponentHealth[]): HealthStatus {\n    if (components.length === 0) return 'unknown';\n    \n    const healthyCount = components.filter(c => c.status === 'healthy').length;\n    const degradedCount = components.filter(c => c.status === 'degraded').length;\n    const unhealthyCount = components.filter(c => c.status === 'unhealthy').length;\n    \n    if (unhealthyCount > 0) return 'unhealthy';\n    if (degradedCount > 0) return 'degraded';\n    if (healthyCount === components.length) return 'healthy';\n    \n    return 'unknown';\n  }\n\n  private generateHealthSummary(components: ComponentHealth[], alerts: ActiveAlert[]): HealthSummary {\n    const totalComponents = components.length;\n    const healthyComponents = components.filter(c => c.status === 'healthy').length;\n    const degradedComponents = components.filter(c => c.status === 'degraded').length;\n    const unhealthyComponents = components.filter(c => c.status === 'unhealthy').length;\n    const unknownComponents = components.filter(c => c.status === 'unknown').length;\n    \n    const overallAvailability = totalComponents > 0 \n      ? (healthyComponents / totalComponents) * 100 \n      : 0;\n    \n    const averageResponseTime = components.length > 0\n      ? components.reduce((sum, c) => sum + c.responseTime, 0) / components.length\n      : 0;\n    \n    const activeAlerts = alerts.length;\n    const criticalAlerts = alerts.filter(a => a.severity === 'critical').length;\n    \n    return {\n      totalComponents,\n      healthyComponents,\n      degradedComponents,\n      unhealthyComponents,\n      unknownComponents,\n      overallAvailability,\n      averageResponseTime,\n      activeAlerts,\n      criticalAlerts\n    };\n  }\n\n  private calculateTolerance(values: number[], confidence: number): number {\n    // Simplified tolerance calculation - in production, use proper statistical methods\n    const mean = values.reduce((sum, value) => sum + value, 0) / values.length;\n    const variance = values.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / values.length;\n    const stdDev = Math.sqrt(variance);\n    \n    // Simple 2-sigma rule for 95% confidence\n    return (2 * stdDev / mean) * 100;\n  }\n\n  private calculateTrend(values: number[]): { direction: 'up' | 'down' | 'stable'; rate: number } {\n    if (values.length < 2) return { direction: 'stable', rate: 0 };\n    \n    const recent = values.slice(-10);\n    const older = values.slice(-20, -10);\n    \n    if (older.length === 0) return { direction: 'stable', rate: 0 };\n    \n    const recentAvg = recent.reduce((sum, val) => sum + val, 0) / recent.length;\n    const olderAvg = older.reduce((sum, val) => sum + val, 0) / older.length;\n    \n    const rate = ((recentAvg - olderAvg) / olderAvg) * 100;\n    \n    return {\n      direction: rate > 5 ? 'up' : rate < -5 ? 'down' : 'stable',\n      rate: Math.abs(rate)\n    };\n  }\n\n  private calculateResponseTimeTrend(): { direction: 'up' | 'down' | 'stable'; rate: number } {\n    const allResponseTimes: number[] = [];\n    \n    for (const check of this.healthChecks.values()) {\n      allResponseTimes.push(...check.history.slice(-20).map(h => h.responseTime));\n    }\n    \n    return this.calculateTrend(allResponseTimes);\n  }\n\n  private calculateAvailabilityTrend(): { direction: 'up' | 'down' | 'stable'; rate: number } {\n    const availabilities: number[] = [];\n    \n    for (const check of this.healthChecks.values()) {\n      availabilities.push(check.metrics.availability.uptime);\n    }\n    \n    return this.calculateTrend(availabilities);\n  }\n\n  /**\n   * Shutdown the health monitoring service\n   */\n  async shutdown(): Promise<void> {\n    this.stop();\n    \n    this.healthChecks.clear();\n    this.activeAlerts.clear();\n    this.performanceBaselines.clear();\n    this.systemMetricsHistory.length = 0;\n    \n    await this.prisma.$disconnect();\n    \n    this.emit('service_shutdown');\n  }\n}\n\n// Export singleton instance\nexport const healthMonitor = new HealthMonitorService();