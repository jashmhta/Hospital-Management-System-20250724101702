package com.hms.procedure.service;

import com.hms.procedure.entity.ClinicalProcedure;
import com.hms.procedure.entity.ProcedureType;
import com.hms.procedure.repository.ClinicalProcedureRepository;
import com.hms.procedure.repository.ProcedureTypeRepository;
import com.hms.procedure.exception.ProcedureManagementException;
import com.hms.procedure.exception.ValidationException;
import com.hms.procedure.exception.ResourceConflictException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.CompletableFuture;
import java.math.BigDecimal;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;

/**
 * Procedure Management Service
 * 
 * Comprehensive clinical procedure workflow management service with scheduling,
 * documentation, resource allocation, compliance tracking, and advanced analytics.
 * Handles complete procedure lifecycle from scheduling to completion.
 */
@Service
@Transactional
public class ProcedureManagementService {

    private static final Logger logger = LoggerFactory.getLogger(ProcedureManagementService.class);
    
    // Service constants
    private static final int MAX_PROCEDURES_PER_DAY = 50;
    private static final int MIN_PROCEDURE_INTERVAL_MINUTES = 15;
    private static final int EMERGENCY_SLOT_BUFFER_MINUTES = 30;
    private static final int PRE_PROCEDURE_CHECKLIST_ITEMS = 12;
    private static final int POST_PROCEDURE_CHECKLIST_ITEMS = 8;
    
    @Autowired
    private ClinicalProcedureRepository procedureRepository;
    
    @Autowired
    private ProcedureTypeRepository procedureTypeRepository;
    
    @Autowired
    private ResourceAllocationService resourceService;
    
    @Autowired
    private StaffSchedulingService staffService;
    
    @Autowired
    private ComplianceValidationService complianceService;
    
    @Autowired
    private InsuranceAuthorizationService insuranceService;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private AuditService auditService;
    
    @Autowired
    private QualityMetricsService qualityService;
    
    @Autowired
    private DocumentGenerationService documentService;
    
    private final ObjectMapper objectMapper = new ObjectMapper();

    /**\n     * Schedule a new clinical procedure\n     */\n    @PreAuthorize(\"hasRole('PHYSICIAN') or hasRole('NURSE') or hasRole('SCHEDULER')\")\n    public ClinicalProcedure scheduleProcedure(ClinicalProcedure procedure) {\n        logger.info(\"Scheduling new procedure: {} for patient: {}\", \n                   procedure.getProcedureName(), procedure.getPatientId());\n        \n        try {\n            // Validate procedure request\n            validateProcedureRequest(procedure);\n            \n            // Generate unique procedure code\n            procedure.setProcedureCode(generateProcedureCode());\n            \n            // Check for scheduling conflicts\n            validateSchedulingAvailability(procedure);\n            \n            // Allocate required resources\n            allocateResources(procedure);\n            \n            // Assign qualified staff\n            assignStaff(procedure);\n            \n            // Check insurance authorization requirements\n            checkInsuranceAuthorization(procedure);\n            \n            // Perform compliance validation\n            validateCompliance(procedure);\n            \n            // Calculate estimated costs\n            calculateEstimatedCosts(procedure);\n            \n            // Set initial status and create audit trail\n            procedure.setStatus(ClinicalProcedure.ProcedureStatus.SCHEDULED);\n            procedure.setCreatedBy(getCurrentUser());\n            \n            // Save procedure\n            ClinicalProcedure savedProcedure = procedureRepository.save(procedure);\n            \n            // Send notifications\n            sendProcedureNotifications(savedProcedure, \"SCHEDULED\");\n            \n            // Create audit log\n            auditService.logProcedureScheduled(savedProcedure.getId(), savedProcedure.getProcedureCode());\n            \n            logger.info(\"Successfully scheduled procedure: {} with ID: {}\", \n                       savedProcedure.getProcedureCode(), savedProcedure.getId());\n            \n            return savedProcedure;\n            \n        } catch (Exception e) {\n            logger.error(\"Error scheduling procedure: {}\", e.getMessage(), e);\n            throw new ProcedureManagementException(\"Failed to schedule procedure\", e);\n        }\n    }\n\n    /**\n     * Start procedure execution\n     */\n    @PreAuthorize(\"hasRole('PHYSICIAN') or hasRole('NURSE')\")\n    public ClinicalProcedure startProcedure(Long procedureId) {\n        logger.info(\"Starting procedure with ID: {}\", procedureId);\n        \n        try {\n            ClinicalProcedure procedure = getProcedureById(procedureId);\n            \n            // Validate procedure can be started\n            validateProcedureCanStart(procedure);\n            \n            // Complete pre-procedure checklist validation\n            validatePreProcedureChecklist(procedure);\n            \n            // Verify consent is obtained\n            verifyConsentObtained(procedure);\n            \n            // Confirm resource availability\n            confirmResourceAvailability(procedure);\n            \n            // Start the procedure\n            procedure.startProcedure();\n            procedure.setUpdatedBy(getCurrentUser());\n            \n            // Update resource status\n            resourceService.markResourcesInUse(procedure.getId());\n            \n            // Save procedure\n            ClinicalProcedure updatedProcedure = procedureRepository.save(procedure);\n            \n            // Send real-time notifications\n            sendProcedureNotifications(updatedProcedure, \"STARTED\");\n            \n            // Create audit log\n            auditService.logProcedureStarted(updatedProcedure.getId(), getCurrentUser());\n            \n            logger.info(\"Successfully started procedure: {}\", updatedProcedure.getProcedureCode());\n            \n            return updatedProcedure;\n            \n        } catch (Exception e) {\n            logger.error(\"Error starting procedure {}: {}\", procedureId, e.getMessage(), e);\n            throw new ProcedureManagementException(\"Failed to start procedure\", e);\n        }\n    }\n\n    /**\n     * Complete procedure execution\n     */\n    @PreAuthorize(\"hasRole('PHYSICIAN') or hasRole('NURSE')\")\n    public ClinicalProcedure completeProcedure(Long procedureId, String procedureNotes, \n                                              ClinicalProcedure.ProcedureOutcome outcome) {\n        logger.info(\"Completing procedure with ID: {}\", procedureId);\n        \n        try {\n            ClinicalProcedure procedure = getProcedureById(procedureId);\n            \n            // Validate procedure can be completed\n            validateProcedureCanComplete(procedure);\n            \n            // Complete the procedure\n            procedure.completeProcedure();\n            procedure.setProcedureNotes(procedureNotes);\n            procedure.setOutcome(outcome);\n            procedure.setUpdatedBy(getCurrentUser());\n            \n            // Complete post-procedure checklist\n            completePostProcedureChecklist(procedure);\n            \n            // Generate procedure documentation\n            generateProcedureDocumentation(procedure);\n            \n            // Calculate quality metrics\n            calculateQualityMetrics(procedure);\n            \n            // Update billing information\n            updateBillingInformation(procedure);\n            \n            // Release allocated resources\n            resourceService.releaseResources(procedure.getId());\n            \n            // Update staff availability\n            staffService.updateStaffAvailability(procedure.getId());\n            \n            // Save procedure\n            ClinicalProcedure completedProcedure = procedureRepository.save(procedure);\n            \n            // Send completion notifications\n            sendProcedureNotifications(completedProcedure, \"COMPLETED\");\n            \n            // Schedule follow-up if required\n            if (procedure.getFollowUpRequired()) {\n                scheduleFollowUp(completedProcedure);\n            }\n            \n            // Create audit log\n            auditService.logProcedureCompleted(completedProcedure.getId(), outcome.name());\n            \n            logger.info(\"Successfully completed procedure: {} with outcome: {}\", \n                       completedProcedure.getProcedureCode(), outcome);\n            \n            return completedProcedure;\n            \n        } catch (Exception e) {\n            logger.error(\"Error completing procedure {}: {}\", procedureId, e.getMessage(), e);\n            throw new ProcedureManagementException(\"Failed to complete procedure\", e);\n        }\n    }\n\n    /**\n     * Cancel scheduled procedure\n     */\n    @PreAuthorize(\"hasRole('PHYSICIAN') or hasRole('NURSE') or hasRole('SCHEDULER')\")\n    public ClinicalProcedure cancelProcedure(Long procedureId, String reason) {\n        logger.info(\"Cancelling procedure with ID: {}\", procedureId);\n        \n        try {\n            ClinicalProcedure procedure = getProcedureById(procedureId);\n            \n            // Validate procedure can be cancelled\n            validateProcedureCanCancel(procedure);\n            \n            // Cancel the procedure\n            procedure.cancelProcedure(reason, getCurrentUser());\n            \n            // Release allocated resources\n            resourceService.releaseResources(procedure.getId());\n            \n            // Update staff schedules\n            staffService.updateStaffAvailability(procedure.getId());\n            \n            // Handle insurance authorization cancellation\n            if (procedure.getInsuranceAuthorizationRequired() && \n                procedure.getInsuranceAuthorizationNumber() != null) {\n                insuranceService.cancelAuthorization(procedure.getInsuranceAuthorizationNumber());\n            }\n            \n            // Save procedure\n            ClinicalProcedure cancelledProcedure = procedureRepository.save(procedure);\n            \n            // Send cancellation notifications\n            sendProcedureNotifications(cancelledProcedure, \"CANCELLED\");\n            \n            // Create audit log\n            auditService.logProcedureCancelled(cancelledProcedure.getId(), reason);\n            \n            logger.info(\"Successfully cancelled procedure: {} - Reason: {}\", \n                       cancelledProcedure.getProcedureCode(), reason);\n            \n            return cancelledProcedure;\n            \n        } catch (Exception e) {\n            logger.error(\"Error cancelling procedure {}: {}\", procedureId, e.getMessage(), e);\n            throw new ProcedureManagementException(\"Failed to cancel procedure\", e);\n        }\n    }\n\n    /**\n     * Reschedule procedure\n     */\n    @PreAuthorize(\"hasRole('PHYSICIAN') or hasRole('NURSE') or hasRole('SCHEDULER')\")\n    public ClinicalProcedure rescheduleProcedure(Long procedureId, LocalDateTime newDateTime, String reason) {\n        logger.info(\"Rescheduling procedure with ID: {} to {}\", procedureId, newDateTime);\n        \n        try {\n            ClinicalProcedure procedure = getProcedureById(procedureId);\n            \n            // Validate procedure can be rescheduled\n            validateProcedureCanReschedule(procedure);\n            \n            // Check new time slot availability\n            validateSchedulingAvailability(procedure, newDateTime);\n            \n            // Release current resources\n            resourceService.releaseResources(procedure.getId());\n            \n            // Reschedule the procedure\n            procedure.rescheduleProcedure(newDateTime, reason);\n            \n            // Reallocate resources for new time\n            allocateResources(procedure);\n            \n            // Update staff assignments\n            staffService.rescheduleStaffAssignments(procedure.getId(), newDateTime);\n            \n            // Update insurance authorization if needed\n            if (procedure.getInsuranceAuthorizationRequired()) {\n                insuranceService.updateAuthorizationDate(procedure.getInsuranceAuthorizationNumber(), newDateTime);\n            }\n            \n            // Save procedure\n            ClinicalProcedure rescheduledProcedure = procedureRepository.save(procedure);\n            \n            // Send rescheduling notifications\n            sendProcedureNotifications(rescheduledProcedure, \"RESCHEDULED\");\n            \n            // Create audit log\n            auditService.logProcedureRescheduled(rescheduledProcedure.getId(), newDateTime, reason);\n            \n            logger.info(\"Successfully rescheduled procedure: {} to {}\", \n                       rescheduledProcedure.getProcedureCode(), newDateTime);\n            \n            return rescheduledProcedure;\n            \n        } catch (Exception e) {\n            logger.error(\"Error rescheduling procedure {}: {}\", procedureId, e.getMessage(), e);\n            throw new ProcedureManagementException(\"Failed to reschedule procedure\", e);\n        }\n    }\n\n    /**\n     * Get procedure by ID\n     */\n    @PreAuthorize(\"hasRole('PHYSICIAN') or hasRole('NURSE') or hasRole('SCHEDULER') or hasRole('ADMIN')\")\n    public ClinicalProcedure getProcedureById(Long procedureId) {\n        return procedureRepository.findById(procedureId)\n            .orElseThrow(() -> new ValidationException(\"Procedure not found: \" + procedureId));\n    }\n\n    /**\n     * Get procedures by patient ID\n     */\n    @PreAuthorize(\"hasRole('PHYSICIAN') or hasRole('NURSE') or hasRole('SCHEDULER') or hasRole('ADMIN')\")\n    @Cacheable(value = \"patientProcedures\", key = \"#patientId\")\n    public List<ClinicalProcedure> getProceduresByPatient(Long patientId) {\n        return procedureRepository.findByPatientIdOrderByScheduledDateDesc(patientId);\n    }\n\n    /**\n     * Get daily procedure schedule\n     */\n    @PreAuthorize(\"hasRole('PHYSICIAN') or hasRole('NURSE') or hasRole('SCHEDULER') or hasRole('ADMIN')\")\n    @Cacheable(value = \"dailySchedule\", key = \"#date.toString() + '_' + #departmentId\")\n    public List<ClinicalProcedure> getDailySchedule(LocalDateTime date, Long departmentId) {\n        LocalDateTime startOfDay = date.truncatedTo(ChronoUnit.DAYS);\n        LocalDateTime endOfDay = startOfDay.plusDays(1).minusSeconds(1);\n        \n        if (departmentId != null) {\n            return procedureRepository.findByDepartmentIdAndScheduledDateBetweenOrderByScheduledDate(\n                departmentId, startOfDay, endOfDay);\n        } else {\n            return procedureRepository.findByScheduledDateBetweenOrderByScheduledDate(\n                startOfDay, endOfDay);\n        }\n    }\n\n    /**\n     * Get procedure dashboard metrics\n     */\n    @PreAuthorize(\"hasRole('PHYSICIAN') or hasRole('NURSE') or hasRole('ADMIN')\")\n    @Cacheable(value = \"procedureDashboard\", key = \"#departmentId + '_' + #date.toString()\")\n    public Map<String, Object> getProcedureDashboard(Long departmentId, LocalDateTime date) {\n        Map<String, Object> dashboard = new HashMap<>();\n        \n        try {\n            LocalDateTime startOfDay = date.truncatedTo(ChronoUnit.DAYS);\n            LocalDateTime endOfDay = startOfDay.plusDays(1).minusSeconds(1);\n            \n            // Get basic counts\n            List<ClinicalProcedure> todaysProcedures = getDailySchedule(date, departmentId);\n            \n            dashboard.put(\"totalProcedures\", todaysProcedures.size());\n            dashboard.put(\"scheduledProcedures\", \n                todaysProcedures.stream().filter(ClinicalProcedure::isScheduled).count());\n            dashboard.put(\"inProgressProcedures\", \n                todaysProcedures.stream().filter(ClinicalProcedure::isInProgress).count());\n            dashboard.put(\"completedProcedures\", \n                todaysProcedures.stream().filter(ClinicalProcedure::isCompleted).count());\n            dashboard.put(\"cancelledProcedures\", \n                todaysProcedures.stream().filter(ClinicalProcedure::isCancelled).count());\n            \n            // Get procedure types distribution\n            Map<String, Long> procedureTypes = todaysProcedures.stream()\n                .collect(Collectors.groupingBy(\n                    p -> p.getProcedureType().getName(),\n                    Collectors.counting()));\n            dashboard.put(\"procedureTypeDistribution\", procedureTypes);\n            \n            // Get urgency distribution\n            Map<String, Long> urgencyDistribution = todaysProcedures.stream()\n                .collect(Collectors.groupingBy(\n                    p -> p.getUrgency().name(),\n                    Collectors.counting()));\n            dashboard.put(\"urgencyDistribution\", urgencyDistribution);\n            \n            // Calculate average duration\n            OptionalDouble avgDuration = todaysProcedures.stream()\n                .filter(p -> p.getActualDurationMinutes() != null)\n                .mapToInt(ClinicalProcedure::getActualDurationMinutes)\n                .average();\n            dashboard.put(\"averageDuration\", avgDuration.orElse(0.0));\n            \n            // Get overdue procedures\n            List<ClinicalProcedure> overdueProcedures = todaysProcedures.stream()\n                .filter(ClinicalProcedure::isOverdue)\n                .collect(Collectors.toList());\n            dashboard.put(\"overdueProcedures\", overdueProcedures.size());\n            \n            // Resource utilization\n            Map<String, Object> resourceMetrics = resourceService.getResourceUtilization(departmentId, date);\n            dashboard.put(\"resourceUtilization\", resourceMetrics);\n            \n            // Quality metrics\n            Map<String, Object> qualityMetrics = qualityService.getDailyQualityMetrics(departmentId, date);\n            dashboard.put(\"qualityMetrics\", qualityMetrics);\n            \n            return dashboard;\n            \n        } catch (Exception e) {\n            logger.error(\"Error generating procedure dashboard: {}\", e.getMessage(), e);\n            throw new ProcedureManagementException(\"Failed to generate dashboard\", e);\n        }\n    }\n\n    /**\n     * Get procedure analytics\n     */\n    @PreAuthorize(\"hasRole('ADMIN') or hasRole('PHYSICIAN')\")\n    public Map<String, Object> getProcedureAnalytics(LocalDateTime startDate, LocalDateTime endDate, \n                                                     Long departmentId) {\n        Map<String, Object> analytics = new HashMap<>();\n        \n        try {\n            List<ClinicalProcedure> procedures = procedureRepository\n                .findAnalyticsData(startDate, endDate, departmentId);\n            \n            // Volume trends\n            Map<String, Long> dailyVolumes = procedures.stream()\n                .collect(Collectors.groupingBy(\n                    p -> p.getScheduledDate().toLocalDate().toString(),\n                    Collectors.counting()));\n            analytics.put(\"dailyVolumes\", dailyVolumes);\n            \n            // Success rates\n            long successful = procedures.stream()\n                .filter(p -> p.getOutcome() == ClinicalProcedure.ProcedureOutcome.SUCCESSFUL)\n                .count();\n            double successRate = procedures.isEmpty() ? 0.0 : (successful * 100.0) / procedures.size();\n            analytics.put(\"successRate\", successRate);\n            \n            // Average durations by procedure type\n            Map<String, Double> avgDurationsByType = procedures.stream()\n                .filter(p -> p.getActualDurationMinutes() != null)\n                .collect(Collectors.groupingBy(\n                    p -> p.getProcedureType().getName(),\n                    Collectors.averagingInt(ClinicalProcedure::getActualDurationMinutes)));\n            analytics.put(\"averageDurationsByType\", avgDurationsByType);\n            \n            // Cost analysis\n            BigDecimal totalCosts = procedures.stream()\n                .filter(p -> p.getActualCost() != null)\n                .map(ClinicalProcedure::getActualCost)\n                .reduce(BigDecimal.ZERO, BigDecimal::add);\n            analytics.put(\"totalCosts\", totalCosts);\n            \n            // Cancellation rates\n            long cancelled = procedures.stream()\n                .filter(ClinicalProcedure::isCancelled)\n                .count();\n            double cancellationRate = procedures.isEmpty() ? 0.0 : (cancelled * 100.0) / procedures.size();\n            analytics.put(\"cancellationRate\", cancellationRate);\n            \n            return analytics;\n            \n        } catch (Exception e) {\n            logger.error(\"Error generating procedure analytics: {}\", e.getMessage(), e);\n            throw new ProcedureManagementException(\"Failed to generate analytics\", e);\n        }\n    }\n\n    /**\n     * Automated procedure reminders\n     */\n    @Scheduled(fixedDelay = 300000) // Run every 5 minutes\n    public void sendProcedureReminders() {\n        logger.debug(\"Checking for procedures requiring reminders\");\n        \n        try {\n            LocalDateTime now = LocalDateTime.now();\n            LocalDateTime reminderTime = now.plusHours(24); // 24-hour reminder\n            \n            List<ClinicalProcedure> upcomingProcedures = procedureRepository\n                .findUpcomingProceduresForReminder(now, reminderTime);\n            \n            for (ClinicalProcedure procedure : upcomingProcedures) {\n                sendProcedureReminder(procedure);\n            }\n            \n            logger.debug(\"Sent reminders for {} upcoming procedures\", upcomingProcedures.size());\n            \n        } catch (Exception e) {\n            logger.error(\"Error sending procedure reminders: {}\", e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Monitor overdue procedures\n     */\n    @Scheduled(fixedDelay = 600000) // Run every 10 minutes\n    public void monitorOverdueProcedures() {\n        logger.debug(\"Checking for overdue procedures\");\n        \n        try {\n            List<ClinicalProcedure> overdueProcedures = procedureRepository.findOverdueProcedures();\n            \n            for (ClinicalProcedure procedure : overdueProcedures) {\n                handleOverdueProcedure(procedure);\n            }\n            \n            if (!overdueProcedures.isEmpty()) {\n                logger.warn(\"Found {} overdue procedures\", overdueProcedures.size());\n            }\n            \n        } catch (Exception e) {\n            logger.error(\"Error monitoring overdue procedures: {}\", e.getMessage(), e);\n        }\n    }\n\n    // Helper Methods\n\n    private void validateProcedureRequest(ClinicalProcedure procedure) {\n        if (procedure.getPatientId() == null) {\n            throw new ValidationException(\"Patient ID is required\");\n        }\n        if (procedure.getProcedureType() == null) {\n            throw new ValidationException(\"Procedure type is required\");\n        }\n        if (procedure.getScheduledDate() == null) {\n            throw new ValidationException(\"Scheduled date is required\");\n        }\n        if (procedure.getScheduledDate().isBefore(LocalDateTime.now())) {\n            throw new ValidationException(\"Cannot schedule procedure in the past\");\n        }\n        if (procedure.getDepartmentId() == null) {\n            throw new ValidationException(\"Department is required\");\n        }\n        if (procedure.getPrimaryPhysicianId() == null) {\n            throw new ValidationException(\"Primary physician is required\");\n        }\n    }\n\n    private void validateSchedulingAvailability(ClinicalProcedure procedure) {\n        validateSchedulingAvailability(procedure, procedure.getScheduledDate());\n    }\n\n    private void validateSchedulingAvailability(ClinicalProcedure procedure, LocalDateTime scheduleTime) {\n        // Check for conflicts with existing procedures\n        LocalDateTime startTime = scheduleTime;\n        LocalDateTime endTime = scheduleTime.plusMinutes(procedure.getEstimatedDurationMinutes());\n        \n        List<ClinicalProcedure> conflictingProcedures = procedureRepository\n            .findConflictingProcedures(procedure.getDepartmentId(), startTime, endTime);\n        \n        if (!conflictingProcedures.isEmpty()) {\n            throw new ResourceConflictException(\"Scheduling conflict detected with existing procedures\");\n        }\n        \n        // Check daily procedure limits\n        LocalDateTime dayStart = scheduleTime.truncatedTo(ChronoUnit.DAYS);\n        LocalDateTime dayEnd = dayStart.plusDays(1).minusSeconds(1);\n        \n        long dailyCount = procedureRepository.countByDepartmentIdAndScheduledDateBetween(\n            procedure.getDepartmentId(), dayStart, dayEnd);\n        \n        if (dailyCount >= MAX_PROCEDURES_PER_DAY) {\n            throw new ResourceConflictException(\"Daily procedure limit exceeded\");\n        }\n    }\n\n    private void validateProcedureCanStart(ClinicalProcedure procedure) {\n        if (!procedure.isScheduled()) {\n            throw new ValidationException(\"Procedure must be scheduled to start\");\n        }\n        if (!procedure.getConsentObtained()) {\n            throw new ValidationException(\"Patient consent must be obtained before starting\");\n        }\n        if (!procedure.getPreProcedureChecklistCompleted()) {\n            throw new ValidationException(\"Pre-procedure checklist must be completed\");\n        }\n    }\n\n    private void validateProcedureCanComplete(ClinicalProcedure procedure) {\n        if (!procedure.isInProgress()) {\n            throw new ValidationException(\"Procedure must be in progress to complete\");\n        }\n    }\n\n    private void validateProcedureCanCancel(ClinicalProcedure procedure) {\n        if (procedure.isCompleted() || procedure.isCancelled()) {\n            throw new ValidationException(\"Cannot cancel completed or already cancelled procedure\");\n        }\n    }\n\n    private void validateProcedureCanReschedule(ClinicalProcedure procedure) {\n        if (procedure.isInProgress() || procedure.isCompleted()) {\n            throw new ValidationException(\"Cannot reschedule procedure that is in progress or completed\");\n        }\n    }\n\n    private String generateProcedureCode() {\n        return \"PROC_\" + System.currentTimeMillis() + \"_\" + (int)(Math.random() * 1000);\n    }\n\n    private String getCurrentUser() {\n        // In real implementation, extract from security context\n        return \"system\";\n    }\n\n    // Placeholder methods for comprehensive functionality\n    private void allocateResources(ClinicalProcedure procedure) {\n        resourceService.allocateResources(procedure);\n    }\n\n    private void assignStaff(ClinicalProcedure procedure) {\n        staffService.assignStaff(procedure);\n    }\n\n    private void checkInsuranceAuthorization(ClinicalProcedure procedure) {\n        if (procedure.getInsuranceAuthorizationRequired()) {\n            insuranceService.checkAuthorization(procedure);\n        }\n    }\n\n    private void validateCompliance(ClinicalProcedure procedure) {\n        complianceService.validateProcedureCompliance(procedure);\n    }\n\n    private void calculateEstimatedCosts(ClinicalProcedure procedure) {\n        BigDecimal estimatedCost = resourceService.calculateEstimatedCost(procedure);\n        procedure.setEstimatedCost(estimatedCost);\n    }\n\n    private void validatePreProcedureChecklist(ClinicalProcedure procedure) {\n        // Implementation would validate specific checklist items\n        procedure.setPreProcedureChecklistCompleted(true);\n    }\n\n    private void verifyConsentObtained(ClinicalProcedure procedure) {\n        if (!procedure.getConsentObtained()) {\n            throw new ValidationException(\"Patient consent not obtained\");\n        }\n    }\n\n    private void confirmResourceAvailability(ClinicalProcedure procedure) {\n        resourceService.confirmAvailability(procedure.getId());\n    }\n\n    private void completePostProcedureChecklist(ClinicalProcedure procedure) {\n        // Implementation would complete specific checklist items\n        procedure.setPostProcedureChecklistCompleted(true);\n    }\n\n    private void generateProcedureDocumentation(ClinicalProcedure procedure) {\n        documentService.generateProcedureReport(procedure);\n    }\n\n    private void calculateQualityMetrics(ClinicalProcedure procedure) {\n        Map<String, Object> metrics = qualityService.calculateProcedureMetrics(procedure);\n        try {\n            procedure.setQualityMetricsJson(objectMapper.writeValueAsString(metrics));\n        } catch (JsonProcessingException e) {\n            logger.warn(\"Error serializing quality metrics: {}\", e.getMessage());\n        }\n    }\n\n    private void updateBillingInformation(ClinicalProcedure procedure) {\n        BigDecimal actualCost = resourceService.calculateActualCost(procedure);\n        procedure.setActualCost(actualCost);\n    }\n\n    private void scheduleFollowUp(ClinicalProcedure procedure) {\n        // Implementation would schedule follow-up appointment\n        logger.info(\"Scheduling follow-up for procedure: {}\", procedure.getProcedureCode());\n    }\n\n    private void sendProcedureNotifications(ClinicalProcedure procedure, String eventType) {\n        notificationService.sendProcedureNotification(procedure, eventType);\n    }\n\n    private void sendProcedureReminder(ClinicalProcedure procedure) {\n        notificationService.sendProcedureReminder(procedure);\n    }\n\n    private void handleOverdueProcedure(ClinicalProcedure procedure) {\n        logger.warn(\"Handling overdue procedure: {}\", procedure.getProcedureCode());\n        notificationService.sendOverdueAlert(procedure);\n    }\n}\n"
